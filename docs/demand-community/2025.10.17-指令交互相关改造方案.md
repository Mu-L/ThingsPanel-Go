# 指令交互相关改造方案

**日期**: 2025-10-17
**版本**: v6.0 (响应走上行 Flow)
**目标**: 改造指令下发机制，响应数据走上行 Flow 架构，彻底解耦上下行

---

## 一、现状问题

### 1.1 核心问题

❌ **集群不兼容**: `MqttResponseFuncMap` 是内存 map，响应可能路由到其他节点
❌ **内存泄漏风险**: channel 超时后永久占用（6分钟）
❌ **代码重复**: 命令/属性、设备/网关各自实现，逻辑相似度 90%+
❌ **架构混乱**: 响应是上行数据，却用下行逻辑处理

---

## 二、核心设计思路

### 2.1 架构原则

**关键认知**：**响应是上行数据，应该走 Flow 架构**

1. ✅ **下行 Bus 只负责指令下发**（命令、属性设置）
2. ✅ **响应走上行 Flow**（作为一种新的数据类型）
3. ✅ **完全异步**：API 立即返回，响应通过 Flow 更新日志

### 2.2 架构对比

#### 旧架构
```
下行: API → Service → MQTT → 内存 map 等待 → 响应更新
      ❌ 同步等待，集群不兼容
```

#### 新架构
```
下行: API → downlink.Bus → Handler → MQTT → 设备
      ✅ 异步发送，立即返回

上行: 设备响应 → MQTT → Adapter → flow.Bus → ResponseFlow → 更新日志
      ✅ 响应作为上行数据处理
```

---

## 三、目录结构设计

```
internal/
├── flow/                    # 上行数据流（扩展）
│   ├── bus.go              # 上行消息总线
│   ├── telemetry.go
│   ├── attribute.go
│   ├── event.go
│   └── response.go         # 响应数据流（新增）✨
│
├── downlink/               # 下行控制流（新增）✨
│   ├── bus.go             # 下行消息总线
│   ├── handler.go         # 下行处理器（只负责发送）
│   └── types.go           # 消息类型定义
│
├── adapter/                # 协议适配层（扩展）
│   └── mqtt_adapter.go    # 订阅响应 Topic → flow.Bus
│
└── service/                # API 层（改造）
    ├── command_data.go    # 调用 downlink.Publish()
    └── attribute_data.go  # 调用 downlink.Publish()
```

### 依赖关系
```
service → downlink (下行)
adapter → flow.Bus (上行，包括响应)
downlink → MQTTPublisher 接口
✅ 上下行完全解耦
```

---

## 四、核心流程设计

### 4.1 下行流程（命令/属性下发）

```
1. API 层
   ├─ 权限校验、生成 message_id
   ├─ 处理网关层级
   ├─ 创建 pending 日志
   └─ 发送到 downlink.Bus
      └─ 立即返回 {message_id, status: "sent"}

2. downlink.Handler
   ├─ 脚本编码
   ├─ 构造 MQTT Topic
   └─ MQTT 发布
```

### 4.2 响应流程（上行数据）

```
1. 设备响应 → MQTT

2. MQTTAdapter（订阅响应 Topic）
   ├─ devices/command/response/+
   ├─ devices/attributes/set/response/+
   ├─ gateway/command/response/+
   └─ gateway/attributes/set/response/+
   
3. Adapter 构造 FlowMessage
   Type = "command_response" / "attribute_set_response"
   Metadata["message_id"] = xxx
   
4. 发送到 flow.Bus

5. ResponseFlow（新增）
   ├─ 解析响应数据
   ├─ 判断成功/失败
   └─ 更新日志表（按 message_id）
```

---

## 五、关键组件设计

### 5.1 Flow 架构扩展

**新增响应类型**:
```go
// flow/bus.go
const (
    MessageTypeTelemetry = "telemetry"
    MessageTypeAttribute = "attribute"
    MessageTypeEvent     = "event"
    
    // 新增响应类型
    MessageTypeCommandResponse      = "command_response"
    MessageTypeAttributeSetResponse = "attribute_set_response"
)
```

**ResponseFlow**:
```go
// flow/response.go
type ResponseFlow struct {
    logger *logrus.Logger
    db     *gorm.DB
}

func (f *ResponseFlow) Process(msg *FlowMessage) {
    // 1. 提取 message_id
    // 2. 解析响应数据
    // 3. 判断成功/失败
    // 4. 更新日志表
}
```

### 5.2 Adapter 扩展

**订阅响应 Topic**:
```go
// adapter/mqtt_adapter.go
func (a *MQTTAdapter) Start() {
    // 上行数据订阅（已有）
    a.subscribeUplink()
    
    // 响应订阅（新增）
    a.subscribeResponse()
}

func (a *MQTTAdapter) subscribeResponse() {
    topics := []string{
        "devices/command/response/+",
        "devices/attributes/set/response/+",
        "gateway/command/response/+",
        "gateway/attributes/set/response/+",
    }
    
    for _, topic := range topics {
        mqttClient.Subscribe(topic, 1, a.handleResponse)
    }
}

func (a *MQTTAdapter) handleResponse(client mqtt.Client, msg mqtt.Message) {
    // 1. 提取 message_id（从 Topic）
    // 2. 判断消息类型（command/attribute_set）
    // 3. 构造 FlowMessage
    // 4. 发送到 flow.Bus
}
```

### 5.3 downlink 包职责

**只负责下行发送，不处理响应**:

```
downlink/
├── bus.go       # 下行消息总线
├── handler.go   # 下行处理器（编码+发送）
└── types.go     # 下行消息类型
```

---

## 六、组件职责

| 组件 | 职责 | 依赖 |
|------|------|------|
| **downlink.Bus** | 路由下行消息 | 无 |
| **downlink.Handler** | 编码+发送命令 | MQTTPublisher、DataScript |
| **flow.Bus** | 路由上行消息（含响应） | 无 |
| **flow.ResponseFlow** | 处理响应、更新日志 | DAL |
| **MQTTAdapter** | 订阅响应 Topic | mqtt.Client、flow.Bus |
| **Service** | 业务逻辑、网关层级 | downlink.Bus |

---

## 七、初始化流程

```
main.go:
  1. 初始化 MQTT 客户端
  2. 创建 flow.Bus（上行）
  3. 创建 downlink.Bus（下行）
  4. 创建 MQTTAdapter
     ├─ 注入 flow.Bus
     └─ 订阅上行数据 + 响应 Topic
  5. 创建 TelemetryFlow、AttributeFlow、EventFlow
  6. 创建 ResponseFlow（新增）✨
  7. 创建 downlink.Handler
  8. 启动所有 Flow
```

---

## 八、改造范围

### 8.1 需要改造

| 模块 | 改造内容 | 复杂度 |
|------|---------|--------|
| **新增 downlink 包** | Bus + Handler | 简单 |
| **新增 flow/response.go** | ResponseFlow | 简单 |
| **扩展 adapter** | 订阅响应 Topic | 简单 |
| **扩展 flow.Bus** | 新增响应类型 | 简单 |
| **service** | 改为调用 downlink.Publish() | 简单 |

### 8.2 保持不变

| 模块 | 说明 |
|------|------|
| **现有 Flow** | Telemetry/Attribute/Event 不变 |
| **MQTT 客户端** | 全局客户端不变 |
| **数据库表** | 日志表结构不变 |
| **网关层级处理** | 复用现有逻辑 |

---

## 九、改造收益

### 9.1 架构层面
✅ **架构一致**: 响应作为上行数据，走统一 Flow 架构
✅ **职责清晰**: 下行只负责发送，上行处理所有接收
✅ **完全解耦**: 下行和上行互不依赖

### 9.2 功能层面
✅ **集群支持**: 异步处理，任意节点可处理响应
✅ **资源优化**: 无 channel 泄漏
✅ **代码复用**: 消除 70%+ 重复代码

---

## 十、风险和注意事项

### 10.1 API 行为变化

**变化**: 从同步改为异步
- **旧**: 等待 6 分钟返回结果
- **新**: 立即返回 `{message_id, status: "sent"}`

**前端适配**: 轮询或 WebSocket 获取结果

### 10.2 message_id 索引

```sql
CREATE INDEX idx_message_id ON command_set_logs(message_id);
CREATE INDEX idx_message_id ON attribute_set_logs(message_id);
```

### 10.3 超时清理

```sql
UPDATE command_set_logs SET status='3'
WHERE status='0' AND created_at < NOW() - INTERVAL 5 MINUTE;
```

---

## 十一、总结

### 核心设计

1. **下行专注发送**: downlink 包只负责命令下发
2. **响应走上行**: 响应作为上行数据，复用 Flow 架构
3. **完全异步**: API 不等待响应，由 ResponseFlow 更新日志
4. **架构统一**: 上行和下行各司其职，互不干扰

### 关键优势

| 维度 | 旧架构 | 新架构 |
|------|--------|--------|
| **架构一致性** | ❌ 响应逻辑独立 | ✅ 响应走 Flow |
| **集群支持** | ❌ 内存 map | ✅ 异步日志 |
| **资源管理** | ❌ channel 泄漏 | ✅ 无泄漏 |
| **职责划分** | ⚠️ 混乱 | ✅ 清晰 |

---

**最后更新**: 2025-10-17
**版本**: v6.0 (响应走上行 Flow)
