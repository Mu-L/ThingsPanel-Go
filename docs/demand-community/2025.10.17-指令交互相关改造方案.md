# 指令交互改造方案（2025.10 更新）

- **日期**：2025-10-17  
- **适用版本**：v6.0（响应统一走上行 Flow）  
- **目标**：指令下发与响应完全解耦，响应链路纳入上行 Flow，保障集群一致性与可观测性。

## 1. 背景问题
- 指令响应曾依赖单节点内存 map 等待结果，集群环境下易错失响应。
- 长时间同步阻塞导致 API 体验差且存在 goroutine、channel 占用风险。
- 命令与属性设置各自维护一套逻辑，维护成本高。
- 响应本质是上行数据，却挤占下行逻辑，架构断层。

## 2. 改造总览
- **下行链路**：Service 在生成 `message_id` 和日志后，把命令或属性设置投递到 `downlink.Bus`，立即返回调用方。
- **协议层**：`MQTTPublisher` 负责真正的 MQTT 发布；Adapter 只负责上行订阅和封装。
- **上行链路**：设备响应经 MQTT 进入 `MQTTAdapter`，转换为统一 `DeviceMessage` 后投递到 `flow.Bus`，由 `ResponseFlow` 处理并回写日志。
- **状态管理**：日志初始为 `pending`，发送成功置为 `sent`，收到响应后更新为 `success` 或 `failed`，并写入错误描述。

## 3. 当前目录结构
- `internal/downlink/`：包含下行消息总线、处理器、消息定义、发布接口等，仅负责发送。
- `internal/flow/response.go`：新建响应处理流程，与遥测、属性等流程并列，负责解析响应并更新数据库。
- `internal/adapter/mqtt_adapter.go`：新增响应 Topic 订阅，转换后推送到 `flow.Bus`。
- `internal/app/downlink.go`：提供 `WithDownlinkService()` 启动选项，把 Downlink 注入 Service 层并托管生命周期。
- `main.go`：按顺序挂载 Flow、Downlink、Heartbeat 等服务，保证依赖注入。

## 4. 核心流程说明
### 4.1 下行发起
1. Service 层完成权限校验、网关层级展开、生成 `message_id`，写入命令或属性日志，状态为待发送。  
2. 组装 `downlink.Message`（含设备信息、Topic、原始指令数据、配置引用等），投递到 `downlink.Bus` 对应通道。  
3. `downlink.Handler` 读取消息，视设备是否配置脚本决定是否执行编码，并调用 `MessagePublisher` 发布。  
4. 发布成功即把日志状态更新为发送成功；失败则记录错误并标记为失败。API 调用方已在第一步收到 `{message_id, status: "sent"}`。

### 4.2 响应回流
1. 设备或网关通过约定的响应 Topic 回传结果，包含 `message_id`。  
2. `MQTTAdapter` 在响应回调中识别 Topic，推断消息类型（命令或属性设置，直连或网关），并把 `message_id` 放入 metadata。  
3. 消息送入 `flow.Bus` 的响应 channel。`FlowManager` 将其交给 `ResponseFlow`。  
4. `ResponseFlow` 解析 payload，判断 `result`、`errcode` 等字段，形成成功或失败结论，并写回对应日志。  
5. 日志更新触发后续通知机制（如 SSE、轮询）即可得知指令执行结果。

## 5. 组件职责
- **Service 层**：统一创建日志、生成 `message_id`、写入 DownlinkBus，并在 API 层立即返回。  
- **downlink.Bus**：分离命令与属性通道，避免互相阻塞。  
- **downlink.Handler**：串行处理发送动作，负责脚本编码、调用发布接口、更新发送状态。  
- **MQTTPublisher**：封装 MQTT 发布细节，可替换为其他协议实现。  
- **MQTTAdapter**：订阅响应 Topic，转换为 `DeviceMessage`，注入 Flow。  
- **flow.Bus**：统一承载上行消息，新增响应 channel，与遥测/属性/事件并行。  
- **ResponseFlow**：基于 message_id 定位日志，更新状态与错误信息，写入审计日志。  
- **Query/DAL**：提供日志查询与更新能力，支撑 ResponseFlow 落库。  
- **HeartbeatMonitor**：与本改造无直接耦合，但继续通过 Flow.Bus 发布离线事件，保持架构一致。

## 6. 初始化与配置
- `flow.enable` 控制 Flow 层是否启用；下行服务默认跟随启动。  
- `flow.bus_buffer_size` 与 `downlink.buffer_size` 提供独立缓冲设置。  
- `WithFlowService()` 必须在 `WithHeartbeatMonitor()` 之前注册，以确保 ResponseFlow 可用。  
- `WithDownlinkService()` 在 Flow 之后执行，保障下行 Handler 依赖的 Processor、Publisher 均已准备。

## 7. 改造收益
- **集群友好**：响应走上行 Flow，任何节点都能消费并回写日志，彻底摆脱本地内存依赖。  
- **资源可控**：API 不再阻塞等待，避免 goroutine 或 channel 长期占用。  
- **职责清晰**：下行只负责发送，上行负责接收，代码复用度大幅提升。  
- **观测增强**：日志全链路记录，结合现有 metrics/SSE，可清楚追踪指令状态。  
- **扩展性好**：新增协议时只需实现新的 Publisher 或 Adapter，Flow 链路保持不变。

## 8. 注意事项与建议
- 确保命令、属性日志表对 `message_id` 建索引，避免响应更新时全表扫描。  
- 前端需改为异步查询结果，可通过轮询或 SSE 监听。  
- 保留定时任务兜底，将长时间未更新的日志标记为超时，提示设备未响应。  
- 若后续接入 HTTP 或 CoAP 响应，仅需在对应 Adapter 中封装后写入 `flow.Bus`，保持同一规范。
