# WebSocket 实时推送设计（多实例）

## 一、需求背景

前端通过 WebSocket (`/api/v1/telemetry/datas/current/ws` 和 `/api/v1/telemetry/datas/current/keys/ws`) 订阅设备实时遥测数据，后端需要在设备上报数据后立即推送到前端。

**关键约束**：
- 客户端订阅数量少（通常 < 100 个）
- 设备数量可能很大（百万级）
- 多实例部署，客户端可能连接到任意实例
- 只推送被订阅的设备数据，避免浪费

**当前问题**：
- 每个 WebSocket 连接创建独立的 MQTT 客户端（资源浪费）
- 直接订阅 MQTT Broker，绕过 Uplink 层数据处理
- 数据未经过脚本解析和格式转换
- 百万设备场景下无法优化推送

---

## 二、核心设计原则

### 按需推送
```
只为"有订阅者"的设备推送数据，无订阅者的设备数据不推送
```

### 复用 Uplink 数据流
```
不创建独立 MQTT 客户端，复用 Uplink 层已解析、已格式化的数据
```

### 解耦架构
```
Uplink 层不关心推送细节，通过 Redis 解耦推送逻辑
```

### 多实例兼容
```
订阅表和消息分发都通过 Redis，支持任意实例接收和推送
```

---

## 三、整体架构

```
┌─────────────┐
│   设备上报   │
└──────┬──────┘
       │ MQTT
┌──────▼─────────────────────────────────┐
│ Adapter → Uplink Bus → Uplink Handler  │
│                        ↓                │
│  1. 数据脚本解析                        │
│  2. 转换为业务格式                      │
│  3. 检查 Redis 订阅表                  │
│  4. 有订阅者 → 推送到 Redis Pub/Sub   │
│  5. 入库 Storage                       │
│  6. 场景联动                           │
└──────┬─────────────────────────────────┘
       │ Redis Pub/Sub
       │ (ws:device:{deviceID})
       │
┌──────▼─────────────────────────────────┐
│ 所有实例的 WebSocketManager 监听      │
│  ↓                                     │
│ 判断"本实例是否有该设备订阅者"         │
│  ↓                                     │
│ 有 → 推送到前端 WebSocket 连接        │
│ 无 → 忽略                              │
└──────┬─────────────────────────────────┘
       │ WebSocket
┌──────▼──────┐
│  前端客户端  │
└─────────────┘
```

---

## 四、Redis 数据结构设计

### 4.1 订阅表（按设备）

**Key 格式**：
```
ws:sub:{deviceID}
```

**Value**：
```
订阅者数量（整数）
```

**TTL**：
```
300 秒（5 分钟），客户端心跳续期
```

**操作**：
- 订阅时：`INCR ws:sub:{deviceID}`
- 断开时：`DECR ws:sub:{deviceID}`
- 心跳时：`EXPIRE ws:sub:{deviceID} 300`
- 检查时：`EXISTS ws:sub:{deviceID}`

**优势**：
- 原子操作，多实例安全
- 自动过期，防止僵尸订阅
- 查询极快（O(1)）

---

### 4.2 消息分发（Pub/Sub）

**Channel 格式**：
```
ws:device:{deviceID}
```

**消息格式**（JSON）：
```json
{
  "device_id": "xxx",
  "tenant_id": "yyy",
  "timestamp": 1234567890,
  "data": {
    "temperature": 25.5,
    "humidity": 60
  }
}
```

**操作**：
- Uplink 推送：`PUBLISH ws:device:{deviceID} {JSON}`
- WebSocketManager 监听：`PSUBSCRIBE ws:device:*`

---

## 五、数据流详解

### 5.1 客户端订阅流程

```
1. 前端建立连接:
   WebSocket /api/v1/telemetry/datas/current/ws

2. 客户端发送初始消息:
   {
     "device_id": "xxx",
     "token": "yyy"  // 或 "api_key": "zzz"
   }

3. API 层处理:
   - 验证 token/api_key
   - INCR ws:sub:{deviceID}
   - EXPIRE ws:sub:{deviceID} 300
   - 将连接注册到本地 WebSocketManager
   - 发送当前最新数据（从数据库查询）

4. 保持连接:
   - 客户端定期发送心跳（ping/pong）
   - 服务端每 2 分钟续期 Redis TTL

5. 断开连接:
   - DECR ws:sub:{deviceID}
   - 从本地 WebSocketManager 移除连接
```

---

### 5.2 设备数据上报流程

```
1. 设备上报 → Adapter → Uplink Bus

2. Uplink Handler 处理:
   TelemetryUplink.processDirectDeviceMessage()
     ├─ 数据脚本解析
     ├─ 转换为 TelemetryDataPoint 列表
     ├─ 检查订阅表:
     │    EXISTS ws:sub:{deviceID}
     │    ↓
     │    存在 → 推送到 Redis
     │    PUBLISH ws:device:{deviceID} {JSON}
     │    ↓
     │    不存在 → 跳过（性能关键）
     ├─ 发送到 Storage（入库）
     └─ 触发场景联动

3. 所有实例的 WebSocketManager 接收 Redis 消息:
   ├─ 检查本实例是否有该设备订阅者
   ├─ 有 → 推送到前端 WebSocket 连接
   └─ 无 → 忽略
```

---

## 六、关键接口

### 6.1 WebSocket API

#### 接口 1: 订阅全部遥测数据

```
WebSocket /api/v1/telemetry/datas/current/ws

初始消息（客户端 → 服务端）:
{
  "device_id": "xxx",
  "token": "yyy"      // JWT Token
  // 或
  "api_key": "zzz"    // API Key
}

响应消息（服务端 → 客户端）:
1. 当前最新数据（立即返回）:
{
  "temperature": 25.5,
  "humidity": 60,
  "systime": "2025-01-20T10:30:00Z"
}

2. 实时推送数据（设备上报时）:
{
  "temperature": 25.6,
  "humidity": 61,
  "systime": "2025-01-20T10:30:05Z"
}

心跳:
- 客户端每 30 秒发送任意消息（如 "ping"）
- 服务端响应 "pong"
```

---

#### 接口 2: 订阅指定 Keys 的遥测数据

```
WebSocket /api/v1/telemetry/datas/current/keys/ws

初始消息（客户端 → 服务端）:
{
  "device_id": "xxx",
  "keys": ["temperature", "humidity"],
  "token": "yyy"
}

响应消息（服务端 → 客户端）:
只推送 keys 中指定的字段:
{
  "temperature": 25.5,
  "humidity": 60,
  "systime": "2025-01-20T10:30:00Z"
}
```

---

### 6.2 Uplink 层接口

**每个 Uplink Handler 添加方法**：

```
checkAndPublishToWS(deviceID, data)

功能：
1. 检查 Redis 订阅表（EXISTS ws:sub:{deviceID}）
2. 有订阅者 → 推送到 Redis Pub/Sub
3. 异步执行，不阻塞主流程

调用位置：
- TelemetryUplink.processDirectDeviceMessage()
- AttributeUplink.processDirectDeviceMessage()（可选）
- EventUplink.processDirectDeviceMessage()（可选）
```

---

### 6.3 WebSocketManager 接口

```
SubscribeDevice(deviceID, connID, conn)
UnsubscribeDevice(deviceID, connID)
PushToDevice(deviceID, data)

内部维护：
- deviceSubscriptions: map[deviceID][connID]*WebSocketConn
- Redis 订阅表同步
- Redis Pub/Sub 监听
```

---

## 七、性能优化

### 7.1 减少无效推送

**关键优化**：
```
只检查 Redis 订阅表（EXISTS），不推送未订阅设备数据
```

**性能收益**：
- 100 万设备上报 → 仅 10 个设备有订阅
- Redis 查询：100 万次 EXISTS（极快，< 0.1ms/次）
- 消息推送：仅 10 次 PUBLISH（减少 99.999% 流量）

---

### 7.2 异步推送

**关键优化**：
```
WebSocket 推送使用 goroutine，不阻塞主业务流程
```

**实现**：
```
在 Uplink 中异步调用推送逻辑
主流程（数据存储、场景联动）不受影响
```

---

### 7.3 复用 Uplink 数据

**关键优化**：
```
不创建独立 MQTT 客户端，直接使用 Uplink 已解析的数据
```

**收益**：
- 减少 MQTT 连接数（每个 WebSocket 不再创建 MQTT 客户端）
- 数据已经过脚本解析和格式转换
- 统一数据流，便于监控和调试

---

### 7.4 Keys 过滤

**实现位置**：WebSocketManager

```
根据客户端订阅的 keys，过滤推送数据字段
```

**收益**：
- 减少网络传输量
- 前端只接收关心的字段

---

## 八、与旧架构的对比

### 8.1 旧架构（废弃）

```
前端 WebSocket → API 层 → 创建独立 MQTT 客户端
                              ↓
                         订阅 MQTT Topic
                              ↓
                         直接转发原始消息
```

**问题**：
- 每个 WebSocket 一个 MQTT 客户端（100 个 WS = 100 个 MQTT 连接）
- 绕过 Uplink 数据处理（无脚本解析）
- 无法按需推送（所有设备都要订阅）
- 数据格式不统一

---

### 8.2 新架构

```
前端 WebSocket → API 层 → Redis 订阅表
                              ↓
                         WebSocketManager
                              ↑
                         Redis Pub/Sub
                              ↑
                         Uplink 层推送
```

**优势**：
- 无独立 MQTT 客户端（所有 WS 共享 Uplink 数据流）
- 数据已解析（经过脚本处理）
- 按需推送（仅推送被订阅的设备）
- 多实例兼容（通过 Redis 同步）

---

## 九、部署注意事项

### 9.1 Redis 配置

**必需配置**：
```yaml
redis:
  host: xxx
  port: 6379
  db: 0
  max_idle: 100
  max_active: 500
```

**Pub/Sub 监听**：
```
每个实例启动时自动监听 ws:device:*
```

---

### 9.2 负载均衡

**Nginx 配置要点**：
```
- 支持 WebSocket 协议升级
- 超时时间 > 5 分钟
- 支持长连接
- 配置示例:
  proxy_http_version 1.1;
  proxy_set_header Upgrade $http_upgrade;
  proxy_set_header Connection "upgrade";
  proxy_read_timeout 600s;
```

**客户端连接分布**：
```
任意实例可接受订阅，通过 Redis 同步状态
```

---

### 9.3 监控指标

**关键指标**：
- Redis 订阅表大小（当前订阅设备数）
- Redis Pub/Sub 消息量（推送频率）
- WebSocket 连接数（每个实例）
- 推送延迟（从设备上报到前端接收）
- MQTT 客户端数量（应该减少到 1-2 个）

**告警阈值**：
- 单设备订阅数 > 100（异常）
- 推送延迟 > 1 秒（性能问题）
- MQTT 客户端数 > 10（可能未迁移完成）

---

## 十、与现有架构的关系

### 10.1 复用现有组件

| 组件 | 复用方式 |
|------|---------|
| **Redis** | 复用现有连接池 |
| **Uplink 层** | 在各 Handler 中切入 |
| **WebSocket 路由** | 保持现有路径不变 |

### 10.2 需要删除的组件

| 组件 | 说明 |
|------|------|
| `mqtt/ws_subscribe/mqtt_client.go` | 独立 MQTT 客户端逻辑 |
| `WsMqttClient.SubscribeDeviceTelemetry()` | 旧订阅逻辑 |
| `WsMqttClient.CreateMqttClient()` | 每连接创建客户端 |

### 10.3 不影响现有功能

- 数据存储流程不变
- 场景联动不变
- API 路径不变（前端无需修改）
- 认证方式不变（token/api_key）

---

## 十一、扩展性设计

### 11.1 支持多种数据类型（未来扩展）

**当前**：只推送 Telemetry（遥测数据）

**未来可扩展**：
- Attribute（属性数据）
- Event（事件数据）
- Status（设备状态）

**实现**：
- 在 AttributeUplink、EventUplink 中添加推送逻辑
- 使用不同的 Redis Channel（`ws:attribute:{deviceID}`）
- 前端订阅时指定数据类型

---

### 11.2 支持订阅组（未来扩展）

**Redis Key 设计**：
```
ws:sub:group:{groupID}
```

**实现**：
- 设备上报时，同时检查设备组订阅表
- 推送到 `ws:group:{groupID}` 频道

---

### 11.3 双向通信（未来扩展）

**当前**：单向推送（服务端 → 客户端）

**未来可扩展**：
- 前端发送控制指令（如刷新、切换设备）
- 服务端响应指令结果
- 支持 RPC 模式

---

## 十二、风险与应对

### 风险 1: Redis 压力过大

**场景**：百万设备频繁上报

**应对**：
- EXISTS 操作极快（< 0.1ms）
- 单 Redis 可支撑 > 100 万 QPS
- 必要时使用 Redis Cluster

---

### 风险 2: 订阅表泄漏

**场景**：客户端异常断开，未清理订阅

**应对**：
- TTL 自动过期（5 分钟）
- 心跳机制续期
- WebSocket 断开时强制清理

---

### 风险 3: 推送延迟

**场景**：网络 IO 慢

**应对**：
- 异步推送（goroutine）
- 监控推送延迟
- 必要时增加 Redis Pub/Sub 缓冲区

---

### 风险 4: WebSocket 连接中断

**场景**：网络不稳定，连接频繁断开

**应对**：
- 前端实现自动重连
- 服务端支持断点续传（发送最新数据）
- 日志记录连接异常

---

## 十三、迁移计划

### 13.1 代码改动点

| 位置 | 改动内容 |
|------|---------|
| `internal/uplink/telemetry.go` | 添加 `checkAndPublishToWS()` 调用 |
| `internal/api/telemetry_data.go` | 改用 WebSocketManager，不创建 MQTT 客户端 |
| `pkg/global/` 或 `internal/ws/` | 新增 WebSocketManager |
| `mqtt/ws_subscribe/` | 标记废弃或删除 |

### 13.2 向后兼容

**保留旧逻辑**（可选，过渡期使用）：
- 通过配置开关控制使用新/旧逻辑
- 逐步迁移客户端到新架构
- 监控对比新旧架构性能

**完全废弃旧逻辑**（推荐）：
- 直接替换，不保留旧代码
- 前端无需修改（API 路径不变）
- 减少维护成本
