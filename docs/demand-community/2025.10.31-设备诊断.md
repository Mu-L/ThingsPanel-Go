# MVP 设备诊断面板 - 需求文档

## 一、面板展示

```
┌──────────────────────────────────────────────────────────────────┐
│ 设备诊断 - device_smart_meter_001                      [刷新] ⟳  │
├──────────────────────────────────────────────────────────────────┤
│                                                                   │
│  📊 累计统计概览                                                  │
│  ┌──────────────┬──────────────┬──────────────┐                 │
│  │  上行成功率   │  下行成功率   │  存储成功率   │                 │
│  │              │              │              │                 │
│  │    98.5%    │    100%     │    98.8%    │                 │
│  │   ━━━━━━━   │   ━━━━━━━   │   ━━━━━━━   │                 │
│  │  850/863条  │  500/500条  │  852/863条  │                 │
│  └──────────────┴──────────────┴──────────────┘                 │
│  ⓘ 统计范围：启动至今                                             │
│                                                                   │
├──────────────────────────────────────────────────────────────────┤
│  ❌ 最近失败记录（最多5条）                                       │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │ 时间          方向    阶段        错误描述                   │ │
│  ├────────────────────────────────────────────────────────────┤ │
│  │ 14:32:15     上行    Processor   解码超时：脚本执行>5s      │ │
│  │ 14:30:42     上行    Storage     存储失败：连接超时         │ │
│  │ 14:28:10     下行    Publish     MQTT发布失败：连接断开     │ │
│  │ 14:25:33     上行    Adapter     消息格式错误：缺少字段      │ │
│  │ 14:20:08     下行    Encode      脚本未找到：script_v2      │ │
│  └────────────────────────────────────────────────────────────┘ │
│                                                                   │
└──────────────────────────────────────────────────────────────────┘
```

---

## 二、核心指标

|指标名称|计算公式|说明|
|:-:|:-:|:-:|
|**上行成功率**|`(uplink_total - uplink_failed) / uplink_total × 100%`|消息处理成功率（Adapter + Processor）|
|**下行成功率**|`(downlink_total - downlink_failed) / downlink_total × 100%`|指令下发成功率|
|**存储成功率**|`(uplink_total - storage_failed) / uplink_total × 100%`|数据入库成功率|

---

## 三、数据采集规则

### 统计时机

|事件|统计动作|
|:-:|:-:|
|**处理消息时**|`uplink_total + 1`|
|**处理失败时**|`uplink_failed + 1` + 记录到失败列表|
|**存储失败时**|`storage_failed + 1` + 记录到失败列表（每条失败记录到对应设备）|
|**下行指令时**|`downlink_total + 1`|
|**下行失败时**|`downlink_failed + 1` + 记录到失败列表|

### 枚举值定义

**方向（direction）**
- `uplink`：上行
- `downlink`：下行

**阶段（stage）**
- `adapter`：适配器（消息格式验证）
- `processor`：处理器（脚本解码/编码）
- `storage`：存储（批量写入）
- `encode`：编码（下行脚本编码）
- `publish`：发布（MQTT 发布）

---

## 四、数据存储方案

### Redis 结构

```
# 统计指标（Hash）
Key: device:{device_id}:diagnostics:stats
Fields:
  - uplink_total: 上行消息总数
  - uplink_failed: 上行处理失败数
  - storage_failed: 存储失败数
  - downlink_total: 下行指令总数
  - downlink_failed: 下行失败数

# 失败记录（List，保留最新5条）
Key: device:{device_id}:diagnostics:failures
Value: JSON 字符串 {"timestamp":"...","direction":"...","stage":"...","error":"..."}
```

### 批量写入失败处理

**关键原则**：批量写入可能包含多个设备的数据，每条失败记录必须记录到**对应的设备**上。

1. **批量写入整体失败**：
   - `batchInsert` 失败时，触发 `fallbackInsert` 降级逐条插入
   - `fallbackInsert` 逐条处理，每条数据都有对应的 `device_id`

2. **逐条写入失败**：
   - 在 `fallbackInsert` 中，每条失败单独记录到对应设备的诊断数据
   - **统计**：`device_id` 的 `storage_failed += 1`
   - **诊断记录**：记录到 `device_id` 的失败列表，error 包含具体错误信息
   - **示例**：`{"timestamp":"...","direction":"uplink","stage":"storage","error":"存储失败：连接超时"}`

3. **实现要点**：
   - 在 `fallbackInsert` 的失败分支，调用诊断收集器记录失败
   - 传入对应的 `device_id`，确保记录到正确的设备

---

## 五、API 接口

### 请求
```
GET /api/devices/{device_id}/diagnostics
```

### 响应
```json
{
  "device_id": "device_smart_meter_001",
  "stats": {
    "uplink": {
      "success_rate": 98.5,
      "total": 863,
      "success": 850
    },
    "downlink": {
      "success_rate": 100,
      "total": 500,
      "success": 500
    },
    "storage": {
      "success_rate": 98.8,
      "total": 863,
      "success": 852
    }
  },
  "recent_failures": [
    {
      "timestamp": "2025-10-31T14:32:15Z",
      "direction": "uplink",
      "stage": "processor",
      "error": "解码超时：脚本执行>5s"
    },
    {
      "timestamp": "2025-10-31T14:30:42Z",
      "direction": "uplink",
      "stage": "storage",
      "error": "存储失败：连接超时"
    }
  ]
}
```

**注意**：诊断接口暂不校验权限。

---

## 六、空态展示

```
┌──────────────────────────────────────────────────────────────────┐
│ 设备诊断 - device_new_sensor_999                       [刷新] ⟳  │
├──────────────────────────────────────────────────────────────────┤
│                                                                   │
│  📊 累计统计概览                                                  │
│  ┌──────────────┬──────────────┬──────────────┐                 │
│  │  上行成功率   │  下行成功率   │  存储成功率   │                 │
│  │              │              │              │                 │
│  │      -      │      -      │      -      │                 │
│  │   ━━━━━━━   │   ━━━━━━━   │   ━━━━━━━   │                 │
│  │   暂无数据   │   暂无数据   │   暂无数据   │                 │
│  └──────────────┴──────────────┴──────────────┘                 │
│  ⓘ 该设备尚未产生消息记录                                         │
│                                                                   │
├──────────────────────────────────────────────────────────────────┤
│  ❌ 最近失败记录                                                  │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │                                                             │ │
│  │                      📭                                     │ │
│  │                   暂无失败记录                               │ │
│  │                                                             │ │
│  └────────────────────────────────────────────────────────────┘ │
│                                                                   │
└──────────────────────────────────────────────────────────────────┘
```

---

## 七、技术实现方案

### 架构设计

采用**统一诊断服务模式**（Diagnostics Collector），创建独立模块统一收集统计数据和失败记录。

```
internal/
  diagnostics/
    collector.go      # 统一收集器（单例，异步缓冲）
    metrics.go       # Redis 操作封装
    types.go         # 数据结构定义
```

**优势**：
- 职责清晰，不影响业务代码
- 易于扩展和维护
- 性能影响小（异步缓冲写入）

### 依赖关系分析（避免循环导入）

**✅ 不会形成循环导入**

依赖链如下：
```
diagnostics → pkg/global → (仅标准库和第三方库)
storage/uplink/adapter/downlink → diagnostics (单向)
api → diagnostics (单向)
```

**关键点**：
1. `diagnostics` 只依赖：
   - 标准库（`encoding/json`, `sync`, `time` 等）
   - `pkg/global`（访问 `global.REDIS`）
   - `github.com/redis/go-redis/v9`
   
2. `pkg/global` 只依赖：
   - `internal/middleware/response`（通用中间件，不涉及业务模块）

3. 业务模块（`storage`/`uplink`/`adapter`/`downlink`）通过导入 `diagnostics` 使用，不会形成反向依赖

**结论**：依赖关系是**单向的、无环的**，不会出现循环导入问题。

### 埋点位置

**上行链路**：
1. `adapter/mqttadapter/adapter.go`:
   - `HandleTelemetryMessage`: 验证失败 → `direction: uplink, stage: adapter`
   - `HandleAttributeMessage`: 验证失败 → `direction: uplink, stage: adapter`
   - `HandleEventMessage`: 验证失败 → `direction: uplink, stage: adapter`

2. `uplink/telemetry.go`, `attribute.go`, `event.go`:
   - `processor.Decode` 失败 → `direction: uplink, stage: processor`
   - 发送到 storage 前 → `uplink_total + 1`

3. `storage/telemetry_writer.go`:
   - `fallbackInsert` 逐条失败 → `direction: uplink, stage: storage`（每条失败记录到对应设备）

**下行链路**：
1. `downlink/handler.go`:
   - `encode` 失败 → `direction: downlink, stage: encode`
   - `publish` 失败 → `direction: downlink, stage: publish`
   - 处理开始时 → `downlink_total + 1`

### 配置设计

在 `configs/conf.yml` 中添加：

```yaml
diagnostics:
  enabled: true          # 是否启用设备诊断（关闭时不启动监控）
  max_failures: 5        # 保留失败记录数
  batch_flush_size: 10   # 批量刷新大小（异步缓冲）
  batch_flush_interval: 1s  # 批量刷新间隔
  persist_to_db: false   # 是否持久化到数据库（服务重启后保留）
```

### 技术约束

1. **统计方式**：累计计数（服务启动至今），重启清零（可配置持久化）
2. **存储方案**：Redis（Hash + List）
3. **并发安全**：使用 Redis 原子操作（`HINCRBY`、`LPUSH` + `LTRIM`）
4. **性能优化**：异步缓冲批量写入，不阻塞业务处理
5. **开关控制**：配置 `enabled: false` 时完全关闭诊断功能

---

## 八、实施步骤

1. ✅ 创建 `internal/diagnostics` 模块
2. ✅ 实现收集器（单例，异步缓冲）
3. ✅ 在关键位置埋点（6-8 处）
4. ✅ 添加配置开关（`diagnostics.enabled`）
5. ✅ 实现 API 接口 `GET /api/devices/{device_id}/diagnostics`（不校验权限）
6. ✅ 集成到应用启动流程（检查开关）

---

## 九、MVP 范围

- ✅ 累计统计（启动至今）
- ✅ 三个核心指标（上行/下行/存储成功率）
- ✅ 最近5条失败记录
- ✅ 手动刷新
- ✅ 配置开关控制