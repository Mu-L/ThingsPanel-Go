# MQTT 适配器架构重构设计

## 一、架构分层

### 1.1 整体架构

```
设备 ↔ MQTT Broker ↔ Adapter 层 ↔ Flow 层 ↔ Storage 层
                         ↓
                    Downlink 层
```

### 1.2 各层职责

| 层级 | 职责 | 示例 |
|------|------|------|
| **Adapter 层** | 协议适配、消息格式转换、协议层 ACK | MQTT → FlowMessage |
| **Flow 层** | 业务流程编排、数据处理、联动触发 | 脚本处理、存储、自动化 |
| **Storage 层** | 数据持久化 | 写入 PostgreSQL/时序库 |
| **Downlink 层** | 下行指令处理、脚本编码 | 命令/属性下发 |

### 1.3 依赖方向

```
Flow 层定义接口 ← Adapter 层实现接口
    ↓
Storage/Downlink 层
```

**关键原则**：
- Flow 层不依赖具体协议（MQTT/Kafka/HTTP）
- 通过接口反转避免循环依赖
- Adapter 负责协议交互（接收消息、发送 ACK）

---

## 二、目录结构

### 2.1 目标结构（长期）

```
pkg/
└── mqtt/                          # MQTT 客户端基础库（可复用）
    ├── client.go                 # 客户端封装
    └── config.go                 # 客户端配置

internal/
├── adapter/
│   ├── interfaces.go             # Adapter 接口定义
│   └── mqtt/
│       ├── adapter.go            # MQTTAdapter 实现
│       ├── topics.go             # Topic 常量和构造函数
│       ├── publisher.go          # 响应发送工具
│       └── subscriber.go         # 订阅管理
│
├── flow/                         # 业务流程层
│   ├── bus.go                    # 消息总线
│   ├── interfaces.go             # Flow 层接口定义
│   ├── telemetry.go              # 遥测流程
│   ├── attribute.go              # 属性流程
│   ├── event.go                  # 事件流程
│   ├── status.go                 # 状态流程
│   └── response.go               # 响应流程
│
├── downlink/                     # 下行指令层
│   ├── bus.go
│   └── handler.go
│
├── storage/                      # 存储层
│   └── storage.go
│
└── service/
    ├── interfaces.go             # Service 层接口定义（避免循环依赖）
    └── heartbeat_monitor.go      # 心跳监控

configs/
└── conf.yml                      # 统一配置（包含 MQTT Broker 配置）

mqtt/                             # 待重构目录（暂时保留）
├── init_config.go                # 客户端初始化（待迁移到 pkg/mqtt）
├── publish/                      # 发布工具（待迁移到 adapter/mqtt）
└── subscribe/                    # 旧订阅逻辑（待清理）
```

### 2.2 当前状态

```
internal/adapter/
└── mqtt/                         # ✅ 已调整
    ├── adapter.go
    ├── topics.go
    ├── publisher.go
    └── subscriber.go

mqtt/                             # ⏳ 待清理
├── subscribe/                    # 部分已废弃（被 Flow 替代）
└── publish/                      # 待迁移
```

---

##三、核心设计

### 3.1 上行数据流程（设备 → 平台）

```
设备消息 → MQTT Broker → MQTTAdapter
                              ├─→ 发送到 Flow Bus（异步业务处理）
                              └─→ 立即 ACK 响应（协议层行为）
```

**特点**：
- ACK 响应不等待业务处理完成
- 协议层和业务层分离

### 3.2 下行数据流程（平台 → 设备）

```
API 层 → Downlink Bus → Handler → MQTT Publisher → MQTT Broker → 设备
```

### 3.3 响应数据流程（设备响应 → 更新日志）

```
设备响应 → MQTT Broker → MQTTAdapter → Flow Bus → ResponseFlow → 更新日志表
```

### 3.4 Topic 规范

**设计原则**：
- Topic 是协议规范，定义在代码中（不放配置文件）
- 使用常量定义模板，函数构造实际 Topic

**Topic 定义**（`internal/adapter/mqtt/topics.go`）：

| 方向 | 类型 | Topic 模板 | 说明 |
|------|------|-----------|------|
| 上行 | 属性上报 | `devices/attributes/{message_id}` | 设备上报属性 |
| 上行 | 事件上报 | `devices/event/{message_id}` | 设备上报事件 |
| 上行 | 遥测上报 | `devices/telemetry/{message_id}` | 设备上报遥测 |
| 上行 | 状态上报 | `devices/status/{device_id}` | 设备上下线 |
| 下行 | 属性设置 | `devices/attributes/set/{device_number}` | 平台下发属性 |
| 下行 | 命令下发 | `devices/command/{device_number}` | 平台下发命令 |
| 上行 | 属性响应 | `devices/attributes/set/response/{message_id}` | 设备响应属性设置 |
| 上行 | 命令响应 | `devices/command/response/{message_id}` | 设备响应命令 |

**网关 Topic**：前缀改为 `gateway/`

---

## 四、依赖倒置案例

### 4.1 HeartbeatMonitor 依赖 Flow Bus

**问题**：HeartbeatMonitor（service 层）需要发送状态消息，但不能依赖 Flow 包（循环依赖）

**解决方案**：
```go
// internal/service/interfaces.go
type StatusPublisher interface {
    PublishStatusOffline(deviceID, source string) error
}

// internal/service/heartbeat_monitor.go
type HeartbeatMonitor struct {
    statusPublisher StatusPublisher  // 依赖接口
}

// internal/flow/bus.go
func (b *Bus) PublishStatusOffline(deviceID, source string) error {
    // 实现接口
}

// internal/app/heartbeat.go（组装层）
monitor := service.NewHeartbeatMonitor(
    redis,
    flowBus,  // Bus 实现了 StatusPublisher 接口
    logger,
)
```

**关键**：接口定义在使用方（service），不在实现方（flow）

---

## 五、迁移计划

### 5.1 已完成 ✅

- [x] **上行数据流程重构**
  - Telemetry、Attribute、Event 通过 Flow 层处理
  - Status 消息通过 StatusFlow 处理
  - 数据处理、存储、联动在 Flow 层统一编排

- [x] **响应数据流程重构**
  - Command Response、Attribute Set Response 通过 ResponseFlow 处理
  - 更新日志表状态（status: 3=成功, 4=失败）

- [x] **ACK 响应实现**
  - Adapter 层在接收到属性/事件上报后立即 ACK
  - 不等待业务处理完成

- [x] **HeartbeatMonitor 依赖倒置**
  - 通过 `StatusPublisher` 接口避免循环依赖
  - 接口定义在 `internal/service/interfaces.go`

- [x] **目录结构调整**
  - `mqtt_adapter.go` 移到 `internal/adapter/mqtt/`
  - 创建 `topics.go`、`publisher.go`、`subscriber.go`

### 5.2 待完成 ⏳

- [ ] **迁移 `mqtt/publish/` 到 `internal/adapter/mqtt/publisher.go`**
  - 统一响应发送逻辑
  - 删除 `mqtt/publish/` 中已迁移的代码

- [ ] **清理 `mqtt/subscribe/` 旧代码**
  - `attribute_message.go` - 已被 Adapter 替代
  - `event_message.go` - 已被 Adapter 替代
  - `telemetry_message.go` - 已被 Adapter 替代
  - `command_message.go` - 检查是否还在使用
  - `gateway.go` - 检查网关相关逻辑

- [ ] **创建 `pkg/mqtt/` 基础库**
  - 迁移 `mqtt/init_config.go` → `pkg/mqtt/client.go`
  - 提取可复用的客户端封装

- [ ] **下行指令流程完善**
  - 确认 Downlink 层是否完整
  - 脚本编码、网关嵌套是否正常

---

## 六、配置管理

### 6.1 配置分类

| 配置类型 | 位置 | 说明 |
|---------|------|------|
| **MQTT Broker 配置** | `configs/conf.yml` | 基础设施配置（Broker 地址、用户名、密码） |
| **Topic 规则** | `internal/adapter/mqtt/topics.go` | 协议规范（代码定义，不可配置） |
| **业务配置** | `configs/conf.yml` | Flow、Storage 等业务模块配置 |

### 6.2 为什么 Topic 不放配置文件？

**理由**：
1. Topic 是协议规范的一部分（类似 RESTful API 路由）
2. 修改 Topic 会导致设备无法通信（不应由运维随意修改）
3. 如需自定义协议，应通过"协议插件"扩展，而非配置

---

## 七、扩展性设计

### 7.1 支持多协议

**目标**：未来支持 Kafka、HTTP、CoAP 等协议

**设计**：
```
internal/adapter/
├── interfaces.go             # 通用接口
├── mqtt/                     # MQTT 实现
├── kafka/                    # Kafka 实现（未来）
└── http/                     # HTTP 实现（未来）
```

**接口定义**：
```go
type ProtocolAdapter interface {
    HandleTelemetryMessage(payload []byte, metadata map[string]interface{}) error
    HandleAttributeMessage(payload []byte, metadata map[string]interface{}) error
    HandleEventMessage(payload []byte, metadata map[string]interface{}) error
}
```

### 7.2 协议无关的 Flow 层

Flow 层只依赖 `FlowMessage` 结构，不感知具体协议：
```go
type DeviceMessage struct {
    Type      string                 // 消息类型
    DeviceID  string
    Payload   []byte
    Metadata  map[string]interface{} // 协议相关元数据
}
```

---

## 八、注意事项

### 8.1 循环依赖问题

**常见场景**：
- Service 层需要调用 Flow 层功能
- Flow 层又使用 Service 层的服务

**解决方案**：
1. **接口定义在使用方**（依赖倒置原则）
2. **在 App 层组装依赖**（不在模块内部互相依赖）

### 8.2 响应逻辑的位置

**ACK 响应**（协议层）：
- 位置：`internal/adapter/mqtt/publisher.go`
- 时机：收到消息后立即发送
- 不等待业务处理

**业务响应**（业务层）：
- 位置：`internal/downlink/`
- 时机：业务处理完成后
- 包含业务结果

### 8.3 网关消息处理

网关消息在 Flow 层递归拆分：
```
网关消息 → Adapter → Flow Bus → AttributeFlow/EventFlow
                                      ↓
                              递归处理子设备和子网关
```

---

## 九、测试要点

### 9.1 功能测试

- [ ] 属性上报 + ACK 响应
- [ ] 事件上报 + ACK 响应
- [ ] 命令响应 + 日志更新
- [ ] 属性设置响应 + 日志更新
- [ ] 心跳超时 + 自动离线
- [ ] 网关消息拆分

### 9.2 性能测试

- [ ] 消息吞吐量（Bus channel 缓冲区）
- [ ] 内存占用（避免消息积压）
- [ ] 响应延迟（ACK 响应时间）

---

## 十、后续优化方向

1. **消息可靠性**
   - 消息持久化（避免 Bus 满了丢消息）
   - 重试机制

2. **监控和告警**
   - Bus 队列长度监控
   - 处理失败率监控

3. **协议插件化**
   - 支持自定义协议扩展
   - 热加载协议插件

4. **性能优化**
   - 批量处理
   - 数据压缩
