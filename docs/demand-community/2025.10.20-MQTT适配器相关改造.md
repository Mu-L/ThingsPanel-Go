# MQTT 适配器架构重构设计

## 一、架构分层

### 1.1 整体架构

```
设备 ↔ MQTT Broker ↔ Adapter 层 ↔ Uplink 层 ↔ Storage 层
                         ↓
                    Downlink 层
```

### 1.2 各层职责

| 层级 | 职责 | 示例 |
|------|------|------|
| **Adapter 层** | 协议适配、消息格式转换、协议层 ACK | MQTT → UplinkMessage |
| **Uplink 层** | 上行数据处理、脚本执行、存储、联动触发 | 遥测/属性/事件/状态处理 |
| **Storage 层** | 数据持久化 | 写入 PostgreSQL/时序库 |
| **Downlink 层** | 下行指令处理、脚本编码 | 命令/属性下发 |

### 1.3 依赖方向

```
Uplink 层定义接口 ← Adapter 层实现接口
    ↓
Storage/Downlink 层
```

**关键原则**：
- Uplink 层不依赖具体协议（MQTT/Kafka/HTTP）
- 通过接口反转避免循环依赖
- Adapter 负责协议交互（接收消息、发送 ACK）

---

## 二、目录结构

### 2.1 目标结构（长期）

```
pkg/
└── mqtt/                          # MQTT 客户端基础库（可复用）
    ├── client.go                 # 客户端封装
    └── config.go                 # 客户端配置

internal/
├── adapter/
│   ├── interfaces.go             # Adapter 接口定义
│   └── mqtt/
│       ├── adapter.go            # MQTTAdapter 实现
│       ├── topics.go             # Topic 常量和构造函数
│       ├── publisher.go          # 响应发送工具
│       └── subscriber.go         # 订阅管理
│
├── uplink/                       # 上行数据处理层（原 flow/）
│   ├── bus.go                    # 消息总线
│   ├── interfaces.go             # Uplink 层接口定义
│   ├── telemetry.go              # 遥测数据处理
│   ├── attribute.go              # 属性数据处理
│   ├── event.go                  # 事件数据处理
│   ├── status.go                 # 状态数据处理
│   └── response.go               # 响应数据处理
│
├── downlink/                     # 下行指令层
│   ├── bus.go                    # 指令总线
│   ├── command.go                # 命令下发处理
│   └── attribute.go              # 属性设置处理
│
├── storage/                      # 存储层
│   └── storage.go
│
└── service/
    ├── interfaces.go             # Service 层接口定义（避免循环依赖）
    └── heartbeat_monitor.go      # 心跳监控

configs/
└── conf.yml                      # 统一配置（包含 MQTT Broker 配置）

mqtt/                             # 待重构目录（暂时保留）
├── init_config.go                # 客户端初始化（待迁移到 pkg/mqtt）
├── publish/                      # 发布工具（待迁移到 adapter/mqtt）
└── subscribe/                    # 旧订阅逻辑（待清理）
```

### 2.2 当前状态

```
internal/adapter/
└── mqtt/                         # ✅ 已调整
    ├── adapter.go
    ├── topics.go
    ├── publisher.go
    └── subscriber.go

mqtt/                             # ⏳ 待清理
├── subscribe/                    # 部分已废弃（被 Flow 替代）
└── publish/                      # 待迁移
```

---

##三、核心设计

### 3.1 上行数据流程（设备 → 平台）

```
设备消息 → MQTT Broker → MQTTAdapter
                              ├─→ 发送到 Uplink Bus（异步业务处理）
                              └─→ 立即 ACK 响应（协议层行为）
```

**特点**：
- ACK 响应不等待业务处理完成
- 协议层和业务层分离

### 3.2 下行数据流程（平台 → 设备）

```
API 层 → Downlink Bus → Handler → MQTT Publisher → MQTT Broker → 设备
```

### 3.3 响应数据流程（设备响应 → 更新日志）

```
设备响应 → MQTT Broker → MQTTAdapter → Uplink Bus → ResponseHandler → 更新日志表
```

### 3.4 Topic 规范

**设计原则**：
- Topic 是协议规范，定义在代码中（不放配置文件）
- 使用常量定义模板，函数构造实际 Topic

**Topic 定义**（`internal/adapter/mqttadapter/topics.go`）：

#### 3.4.1 平台订阅的 Topic（接收设备上报数据）

| Topic 模板 | 数据类型 | 说明 |
|-----------|---------|------|
| `devices/telemetry` | 遥测数据 | 设备上报遥测（无 message_id） |
| `devices/attributes/+` | 属性数据 | 设备上报属性（+ 匹配 message_id） |
| `devices/event/+` | 事件数据 | 设备上报事件（+ 匹配 message_id） |
| `devices/status/+` | 状态数据 | 设备上下线状态（+ 匹配 device_id） |
| `devices/command/response/+` | 命令响应 | 设备响应命令（+ 匹配 message_id） |
| `devices/attributes/set/response/+` | 属性设置响应 | 设备响应属性设置（+ 匹配 message_id） |
| `gateway/telemetry` | 网关遥测 | 网关上报遥测（含子设备） |
| `gateway/attributes/+` | 网关属性 | 网关上报属性 |
| `gateway/event/+` | 网关事件 | 网关上报事件 |
| `gateway/command/response/+` | 网关命令响应 | 网关响应命令 |
| `gateway/attributes/set/response/+` | 网关属性设置响应 | 网关响应属性设置 |

#### 3.4.2 平台发布的 Topic（下发数据到设备）

| Topic 模板 | 数据类型 | 说明 | 状态 |
|-----------|---------|------|------|
| `devices/telemetry/control/{device_number}` | 遥测控制 | 控制设备遥测行为 | ✅ 已实现 |
| `devices/attributes/set/{device_number}/{message_id}` | 属性设置 | 下发属性设置 | ⚠️ **待修改**（当前缺少 message_id） |
| `devices/attributes/get/{device_number}` | 属性查询 | 查询设备属性（无需响应） | ✅ 已实现 |
| `devices/command/{device_number}/{message_id}` | 命令下发 | 下发命令 | ⚠️ **待修改**（当前缺少 message_id） |
| `devices/attributes/response/{device_number}/{message_id}` | 属性上报ACK | ACK设备的属性上报 | ✅ 已实现 |
| `devices/event/response/{device_number}/{message_id}` | 事件上报ACK | ACK设备的事件上报 | ✅ 已实现 |
| `gateway/telemetry/control/{gateway_number}` | 网关遥测控制 | 控制网关遥测 | ✅ 已实现 |
| `gateway/attributes/set/{gateway_number}/{message_id}` | 网关属性设置 | 下发网关属性 | ⚠️ **待修改** |
| `gateway/attributes/get/{gateway_number}` | 网关属性查询 | 查询网关属性 | ✅ 已实现 |
| `gateway/command/{gateway_number}/{message_id}` | 网关命令 | 下发网关命令 | ⚠️ **待修改** |
| `gateway/attributes/response/{gateway_number}/{message_id}` | 网关属性ACK | ACK网关属性上报 | ✅ 已实现 |
| `gateway/event/response/{gateway_number}/{message_id}` | 网关事件ACK | ACK网关事件上报 | ✅ 已实现 |

#### 3.4.3 参数说明

- `{message_id}`：消息唯一标识（8位UUID）
  - **平台下发时**：由 Service 层生成，记录到日志表，用于关联设备响应
  - **设备上报时**：由设备生成，平台用于 ACK 响应时原样返回
- `{device_number}`：设备编号（设备端唯一标识）
- `{device_id}`：设备 ID（平台内部 ID）
- `{gateway_number}`：顶层网关设备编号
- `+`：MQTT 单层通配符（平台订阅时使用）

---

## 四、依赖倒置案例

### 4.1 HeartbeatMonitor 依赖 Uplink Bus

**问题**：HeartbeatMonitor（service 层）需要发送状态消息，但不能依赖 Uplink 包（循环依赖）

**解决方案**：
```go
// internal/service/interfaces.go
type StatusPublisher interface {
    PublishStatusOffline(deviceID, source string) error
}

// internal/service/heartbeat_monitor.go
type HeartbeatMonitor struct {
    statusPublisher StatusPublisher  // 依赖接口
}

// internal/uplink/bus.go
func (b *Bus) PublishStatusOffline(deviceID, source string) error {
    // 实现接口
}

// internal/app/heartbeat.go（组装层）
monitor := service.NewHeartbeatMonitor(
    redis,
    uplinkBus,  // Bus 实现了 StatusPublisher 接口
    logger,
)
```

**关键**：接口定义在使用方（service），不在实现方（uplink）

---

## 五、迁移计划

### 5.1 已完成 ✅

- [x] **上行数据流程重构**
  - Telemetry、Attribute、Event 通过 Uplink 层处理
  - Status 消息通过 StatusHandler 处理
  - 数据处理、存储、联动在 Uplink 层统一编排

- [x] **响应数据流程重构**
  - Command Response、Attribute Set Response 通过 ResponseHandler 处理
  - 更新日志表状态（status: 3=成功, 4=失败）

- [x] **ACK 响应实现**
  - Adapter 层在接收到属性/事件上报后立即 ACK
  - 不等待业务处理完成

- [x] **HeartbeatMonitor 依赖倒置**
  - 通过 `StatusPublisher` 接口避免循环依赖
  - 接口定义在 `internal/service/interfaces.go`

- [x] **目录结构调整**
  - `mqtt_adapter.go` 移到 `internal/adapter/mqtt/`
  - 创建 `topics.go`、`publisher.go`、`subscriber.go`

### 5.2 待完成 ⏳

- [ ] **重命名 `internal/flow/` → `internal/uplink/`**
  - 更新所有导入路径
  - 更新注释和文档
  - 确保命名一致性

- [ ] **迁移 `mqtt/publish/` 到 `internal/adapter/mqtt/publisher.go`**
  - 统一响应发送逻辑
  - 删除 `mqtt/publish/` 中已迁移的代码

- [ ] **清理 `mqtt/subscribe/` 旧代码**
  - `attribute_message.go` - 已被 Adapter 替代
  - `event_message.go` - 已被 Adapter 替代
  - `telemetry_message.go` - 已被 Adapter 替代
  - `command_message.go` - 检查是否还在使用
  - `gateway.go` - 检查网关相关逻辑

- [ ] **创建 `pkg/mqtt/` 基础库**
  - 迁移 `mqtt/init_config.go` → `pkg/mqtt/client.go`
  - 提取可复用的客户端封装

- [ ] **下行指令流程完善**
  - 确认 Downlink 层是否完整
  - 脚本编码、网关嵌套是否正常

---

## 六、配置管理

### 6.1 配置分类

| 配置类型 | 位置 | 说明 |
|---------|------|------|
| **MQTT Broker 配置** | `configs/conf.yml` | 基础设施配置（Broker 地址、用户名、密码） |
| **Topic 规则** | `internal/adapter/mqtt/topics.go` | 协议规范（代码定义，不可配置） |
| **业务配置** | `configs/conf.yml` | Flow、Storage 等业务模块配置 |

### 6.2 为什么 Topic 不放配置文件？

**理由**：
1. Topic 是协议规范的一部分（类似 RESTful API 路由）
2. 修改 Topic 会导致设备无法通信（不应由运维随意修改）
3. 如需自定义协议，应通过"协议插件"扩展，而非配置

---

## 七、扩展性设计

### 7.1 支持多协议

**目标**：未来支持 Kafka、HTTP、CoAP 等协议

**设计**：
```
internal/adapter/
├── interfaces.go             # 通用接口
├── mqtt/                     # MQTT 实现
├── kafka/                    # Kafka 实现（未来）
└── http/                     # HTTP 实现（未来）
```

**接口定义**：
```go
type ProtocolAdapter interface {
    HandleTelemetryMessage(payload []byte, metadata map[string]interface{}) error
    HandleAttributeMessage(payload []byte, metadata map[string]interface{}) error
    HandleEventMessage(payload []byte, metadata map[string]interface{}) error
}
```

### 7.2 协议无关的 Uplink 层

Uplink 层只依赖 `UplinkMessage` 结构，不感知具体协议：
```go
type DeviceMessage struct {
    Type      string                 // 消息类型
    DeviceID  string
    Payload   []byte
    Metadata  map[string]interface{} // 协议相关元数据
}
```

---

## 八、注意事项

### 8.1 循环依赖问题

**常见场景**：
- Service 层需要调用 Flow 层功能
- Flow 层又使用 Service 层的服务

**解决方案**：
1. **接口定义在使用方**（依赖倒置原则）
2. **在 App 层组装依赖**（不在模块内部互相依赖）

### 8.2 响应逻辑的位置

**ACK 响应**（协议层）：
- 位置：`internal/adapter/mqtt/publisher.go`
- 时机：收到消息后立即发送
- 不等待业务处理

**业务响应**（业务层）：
- 位置：`internal/downlink/`
- 时机：业务处理完成后
- 包含业务结果

### 8.3 网关消息处理

网关消息在 Uplink 层递归拆分：
```
网关消息 → Adapter → Uplink Bus → AttributeHandler/EventHandler
                                      ↓
                              递归处理子设备和子网关
```

---

## 九、测试要点

### 9.1 功能测试

- [ ] 属性上报 + ACK 响应
- [ ] 事件上报 + ACK 响应
- [ ] 命令响应 + 日志更新
- [ ] 属性设置响应 + 日志更新
- [ ] 心跳超时 + 自动离线
- [ ] 网关消息拆分

### 9.2 性能测试

- [ ] 消息吞吐量（Bus channel 缓冲区）
- [ ] 内存占用（避免消息积压）
- [ ] 响应延迟（ACK 响应时间）

---

## 十、后续优化方向

1. **消息可靠性**
   - 消息持久化（避免 Bus 满了丢消息）
   - 重试机制

2. **监控和告警**
   - Bus 队列长度监控
   - 处理失败率监控

3. **协议插件化**
   - 支持自定义协议扩展
   - 热加载协议插件

4. **性能优化**
   - 批量处理
   - 数据压缩

---

## 附录：命名对比

| 原名称 | 新名称 | 说明 |
|--------|--------|------|
| `internal/flow/` | `internal/uplink/` | 上行数据处理层 |
| `UplinkMessage` | `UplinkMessage` | 上行消息结构 |
| `FlowBus` | `UplinkBus` | 上行消息总线 |
| `TelemetryUplink` | `TelemetryHandler` | 遥测处理器 |
| `AttributeUplink` | `AttributeHandler` | 属性处理器 |

**命名原则**：
- `uplink` ↔ `downlink` 数据流向清晰对称
- 符合物联网领域通用术语
- 降低新人理解成本
