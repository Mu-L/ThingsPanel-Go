# 设备状态和心跳重构方案

## 核心业务逻辑

### 在线离线的三种模式

#### 模式1: 消息通知模式 (无配置)
```yaml
配置: device_config.other_config 未配置 heartbeat 和 online_timeout
行为:
  - 完全依赖设备主动上报状态消息
  - devices/status/{id} payload=1 → 设备上线
  - devices/status/{id} payload=0 → 设备下线
  - 业务消息(telemetry/attribute/event)不影响在线状态
  - 无TTL监控
```

#### 模式2: 心跳检测模式 (heartbeat配置)
```yaml
配置: device_config.other_config 配置了 heartbeat=30 (秒)
行为:
  - 完全忽略 devices/status/{id} 消息 ❌
  - 任何业务消息(telemetry/attribute/event)都算"活跃"
  - 收到业务消息时:
      1. 如果设备当前离线 → 自动设为在线 + SSE通知 + 自动化 + 预期数据
      2. 刷新 Redis key: device:{id}:heartbeat (TTL=30秒)
  - TTL到期 → Redis过期事件 → HeartbeatMonitor → Bus → StatusFlow → 设备离线
  
特点: 平台完全控制设备状态,设备无法通过状态消息影响
```

#### 模式3: 超时检测模式 (online_timeout配置)
```yaml
配置: device_config.other_config 配置了 online_timeout=60 (秒)
行为:
  - 处理 devices/status/{id} 消息 ✅
      * payload=1 → 设备上线 + 设置TTL(60秒)
      * payload=0 → 设备离线(但保留TTL key)
  - 任何业务消息(telemetry/attribute/event):
      1. 如果设备当前离线 → 自动设为在线 + SSE通知 + 自动化 + 预期数据
      2. 刷新 Redis key: device:{id}:timeout (TTL=60秒)
  - TTL到期 → Redis过期事件 → HeartbeatMonitor → Bus → StatusFlow → 设备离线
  
特点: 混合模式,既接受设备主动上报,也有平台兜底判断,防止"假在线"
用途: 防止设备在线后长期不上报数据,实际已离线但平台未察觉
```

### 配置优先级
```
heartbeat > online_timeout > 无配置
```
- 如果配置了 `heartbeat`,则使用心跳模式,忽略 `online_timeout`
- 如果只配置了 `online_timeout`,则使用超时模式
- 都没配置,则使用消息通知模式

## 重构方案

### 阶段1: Flow层心跳处理

#### TelemetryFlow/AttributeFlow/EventFlow 统一添加心跳刷新

```go
// internal/flow/telemetry.go (attribute.go, event.go同理)
func (f *TelemetryFlow) processDirectDeviceMessage(device *model.Device, payload []byte, originalMsg *DeviceMessage) {
    // 1. 心跳处理(最优先,确保设备活跃性)
    f.refreshHeartbeat(device)
    
    // 2. 数据转发
    if err := publish.ForwardTelemetryMessage(device.ID, payload); err != nil {
        // ...
    }
    
    // 3. 数据转换和存储
    // 4. 场景联动
}

func (f *TelemetryFlow) refreshHeartbeat(device *model.Device) {
    // 获取心跳配置
    config, err := f.heartbeatService.GetConfig(device)
    if err != nil || config == nil {
        // 无心跳配置,不处理
        return
    }
    
    // 检查是否需要自动上线
    if device.IsOnline != 1 {
        // 设备当前离线,收到消息后自动上线
        if err := dal.UpdateDeviceStatus(device.ID, 1); err != nil {
            f.logger.WithError(err).Error("Failed to auto online device")
        }
        // 清理缓存
        initialize.DelDeviceCache(device.ID)
        
        // SSE通知和自动化
        go f.notifyDeviceOnline(device)
    }
    
    // 刷新心跳 key (优先级: heartbeat > online_timeout)
    if config.Heartbeat > 0 {
        f.heartbeatService.SetHeartbeat(device.ID, config.Heartbeat)
    } else if config.OnlineTimeout > 0 {
        f.heartbeatService.SetTimeout(device.ID, config.OnlineTimeout)
    }
}
```

### 阶段2: StatusFlow 处理状态消息

```go
// internal/flow/status.go
type StatusFlow struct {
    heartbeatService *service.HeartbeatService
    logger           *logrus.Logger
    ctx              context.Context
    cancel           context.CancelFunc
}

func (f *StatusFlow) processStatusMessage(msg *DeviceMessage) {
    // 1. 解析状态 (0=离线, 1=在线)
    status, err := f.parseStatus(msg.Payload)
    if err != nil {
        f.logger.WithError(err).Error("Invalid status value")
        return
    }
    
    // 2. 获取设备信息
    device, err := initialize.GetDeviceCacheById(msg.DeviceID)
    if err != nil {
        f.logger.WithError(err).Error("Device not found")
        return
    }
    
    // 3. 检查心跳配置
    config, err := f.heartbeatService.GetConfig(device)
    
    // 3.1 心跳模式: 忽略状态消息
    if err == nil && config != nil && config.Heartbeat > 0 {
        f.logger.WithFields(logrus.Fields{
            "device_id": device.ID,
            "heartbeat": config.Heartbeat,
            "source":    msg.Metadata["source"], // "heartbeat_expired" or "status_message"
        }).Debug("Device in heartbeat mode, ignoring status message from device")
        
        // 只有来自 HeartbeatMonitor 的离线消息才处理
        if source, ok := msg.Metadata["source"].(string); !ok || source != "heartbeat_expired" {
            return
        }
    }
    
    // 3.2 超时模式: 处理状态消息,并设置/保留TTL
    if err == nil && config != nil && config.OnlineTimeout > 0 {
        // 上线时设置TTL
        if status == 1 {
            if err := f.heartbeatService.SetTimeout(device.ID, config.OnlineTimeout); err != nil {
                f.logger.WithError(err).Error("Failed to set timeout key")
            }
        }
        // 离线时保留TTL key(不删除),等待自然过期或业务消息刷新
    }
    
    // 4. 更新状态
    if err := dal.UpdateDeviceStatus(device.ID, status); err != nil {
        f.logger.WithError(err).Error("Failed to update device status")
        return
    }
    
    // 5. 清理并更新缓存
    initialize.DelDeviceCache(device.ID)
    
    // 6. SSE 通知客户端
    go f.notifyClients(device, status)
    
    // 7. 触发自动化
    go f.triggerAutomation(device, status)
    
    // 8. 预期数据发送(上线时)
    if status == 1 {
        go f.sendExpectedData(device)
    }
}

func (f *StatusFlow) parseStatus(payload []byte) (int16, error) {
    str := string(payload)
    switch str {
    case "0":
        return 0, nil
    case "1":
        return 1, nil
    default:
        return 0, fmt.Errorf("invalid status value: %s (expected 0 or 1)", str)
    }
}
```

### 阶段3: HeartbeatService 服务

```go
// internal/service/heartbeat_service.go
type HeartbeatConfig struct {
    Heartbeat     int // 心跳间隔(秒)
    OnlineTimeout int // 在线超时(秒)
}

type HeartbeatService struct {
    redis  *redis.Client
    logger *logrus.Logger
}

func NewHeartbeatService(redis *redis.Client, logger *logrus.Logger) *HeartbeatService {
    return &HeartbeatService{
        redis:  redis,
        logger: logger,
    }
}

// GetConfig 获取设备的心跳配置
func (s *HeartbeatService) GetConfig(device *model.Device) (*HeartbeatConfig, error) {
    if device.DeviceConfigID == nil {
        return nil, nil
    }
    
    // 从数据库获取设备配置
    deviceConfig, err := dal.GetDeviceConfigByID(*device.DeviceConfigID)
    if err != nil {
        return nil, err
    }
    
    if deviceConfig.OtherConfig == nil {
        return nil, nil
    }
    
    // 解析 other_config JSON
    type OtherConfig struct {
        OnlineTimeout int `json:"online_timeout"`
        Heartbeat     int `json:"heartbeat"`
    }
    
    var config OtherConfig
    if err := json.Unmarshal([]byte(*deviceConfig.OtherConfig), &config); err != nil {
        return nil, err
    }
    
    return &HeartbeatConfig{
        Heartbeat:     config.Heartbeat,
        OnlineTimeout: config.OnlineTimeout,
    }, nil
}

// SetHeartbeat 设置心跳 key
func (s *HeartbeatService) SetHeartbeat(deviceID string, interval int) error {
    key := fmt.Sprintf("device:%s:heartbeat", deviceID)
    return s.redis.Set(context.Background(), key, 1, 
        time.Duration(interval)*time.Second).Err()
}

// SetTimeout 设置超时 key
func (s *HeartbeatService) SetTimeout(deviceID string, timeout int) error {
    key := fmt.Sprintf("device:%s:timeout", deviceID)
    return s.redis.Set(context.Background(), key, 1,
        time.Duration(timeout)*time.Second).Err()
}
```

### 阶段4: HeartbeatMonitor 监控服务

```go
// internal/service/heartbeat_monitor.go
type HeartbeatMonitor struct {
    redis       *redis.Client
    mqttAdapter MQTTAdapterInterface // 用于发送状态消息到Flow层
    logger      *logrus.Logger
    ctx         context.Context
    cancel      context.CancelFunc
}

func NewHeartbeatMonitor(redis *redis.Client, adapter MQTTAdapterInterface, logger *logrus.Logger) *HeartbeatMonitor {
    ctx, cancel := context.WithCancel(context.Background())
    return &HeartbeatMonitor{
        redis:       redis,
        mqttAdapter: adapter,
        logger:      logger,
        ctx:         ctx,
        cancel:      cancel,
    }
}

func (m *HeartbeatMonitor) Start() error {
    // 配置 Redis 过期通知
    if err := m.configureRedis(); err != nil {
        return err
    }
    
    // 订阅过期事件
    dbNum := viper.GetInt("db.redis.db1")
    if dbNum == 0 {
        dbNum = 10
    }
    
    pubsub := m.redis.PSubscribe(m.ctx, fmt.Sprintf("__keyevent@%d__:expired", dbNum))
    
    go func() {
        ch := pubsub.Channel()
        for {
            select {
            case <-m.ctx.Done():
                pubsub.Close()
                return
            case msg := <-ch:
                m.handleExpiredKey(msg)
            }
        }
    }()
    
    return nil
}

func (m *HeartbeatMonitor) handleExpiredKey(msg *redis.Message) {
    // 解析 key: device:{deviceId}:{type}
    if !strings.HasPrefix(msg.Payload, "device:") {
        return
    }
    
    parts := strings.Split(msg.Payload, ":")
    if len(parts) != 3 {
        return
    }
    
    keyType := parts[2]
    if keyType != "heartbeat" && keyType != "timeout" {
        return
    }
    
    deviceID := parts[1]
    
    m.logger.WithFields(logrus.Fields{
        "device_id": deviceID,
        "key_type":  keyType,
    }).Info("Device heartbeat/timeout expired, marking as offline")
    
    // 获取设备信息(用于构造完整消息)
    device, err := initialize.GetDeviceCacheById(deviceID)
    if err != nil {
        m.logger.WithError(err).Error("Failed to get device info")
        return
    }
    
    // 构造状态消息,通过 Adapter 发送到 Bus → StatusFlow
    // metadata 中标记来源,用于日志和监控
    source := "heartbeat_expired"
    if keyType == "timeout" {
        source = "timeout_expired"
    }
    
    // 通过 Adapter 发送,确保走统一的 Flow 层处理
    // Adapter 会添加 source 到 metadata
    if err := m.mqttAdapter.HandleStatusMessage(
        []byte("0"), 
        "devices/status/"+deviceID,
        source, // 传递来源标识
    ); err != nil {
        m.logger.WithError(err).Error("Failed to handle device offline event")
    }
}

func (m *HeartbeatMonitor) Stop() error {
    m.cancel()
    return nil
}
```

### 阶段5: 集成到 Application

```go
// internal/app/flow.go
func WithFlowService() Option {
    return func(a *Application) error {
        // ...existing code
        
        // 创建 HeartbeatService
        heartbeatService := service.NewHeartbeatService(
            global.STATUS_REDIS,
            a.Logger,
        )
        
        // 为所有 Flow 注入 HeartbeatService
        telemetryFlow.SetHeartbeatService(heartbeatService)
        attributeFlow.SetHeartbeatService(heartbeatService)
        eventFlow.SetHeartbeatService(heartbeatService)
        
        // 创建 StatusFlow
        statusFlow := flow.NewStatusFlow(flow.StatusFlowConfig{
            HeartbeatService: heartbeatService,
            Logger:           a.Logger,
        })
        
        // 创建 FlowManager (包含 StatusFlow)
        flowManager := flow.NewFlowManager(flow.FlowManagerConfig{
            Bus:           bus,
            TelemetryFlow: telemetryFlow,
            AttributeFlow: attributeFlow,
            EventFlow:     eventFlow,
            StatusFlow:    statusFlow,
            Logger:        a.Logger,
        })
        
        // ...
    }
}

// internal/app/heartbeat.go
func WithHeartbeatMonitor() Option {
    return func(a *Application) error {
        // 确保 Flow 服务已启动
        if a.flowService == nil {
            return fmt.Errorf("flow service not initialized")
        }
        
        monitor := service.NewHeartbeatMonitor(
            global.STATUS_REDIS,
            a.flowService.mqttAdapter, // 使用 MQTTAdapter 发送状态消息
            a.Logger,
        )
        
        wrapper := &ServiceWrapper{
            name:    "Heartbeat Monitor",
            service: monitor,
        }
        
        a.RegisterService(wrapper)
        return nil
    }
}
```

## 架构图

```
业务消息 (Telemetry/Attribute/Event)
    ↓
Flow层处理
    ↓
检查心跳配置
    ↓
├─ 有心跳配置
│   ├─ 设备离线? → 自动上线 + SSE通知
│   └─ 刷新 Redis key (TTL)
│
└─ 无心跳配置
    └─ 不处理状态


状态消息 (devices/status/{id})
    ↓
StatusFlow处理
    ↓
检查心跳配置
    ↓
├─ 有心跳配置 → 忽略消息 ❌
│
└─ 无心跳配置 → 更新状态 ✅
    └─ 数据库 + 缓存 + SSE + 自动化


Redis过期事件
    ↓
HeartbeatMonitor
    ↓
device:{id}:heartbeat 或 :timeout 过期
    ↓
发送离线状态到 StatusFlow
    ↓
StatusFlow处理离线
    └─ 数据库 + 缓存 + SSE + 自动化
```

## 关键业务规则

### 1. 心跳刷新时机

- **任何业务消息** (telemetry/attribute/event) 都触发心跳刷新
- 包括网关拆分后的子设备和子网关消息
- 状态消息(devices/status)不触发心跳刷新

### 2. 自动上线条件

心跳/超时模式 + 设备当前离线 + 收到业务消息 = 自动上线 + 完整上线流程(SSE + 自动化 + 预期数据)

### 3. 状态消息处理规则

- **心跳模式**: 忽略设备发来的状态消息,只处理 HeartbeatMonitor 发来的离线消息
- **超时模式**: 处理所有状态消息,上线时设置TTL,离线时保留TTL key
- **消息模式**: 处理所有状态消息

### 4. 心跳配置优先级

heartbeat (心跳) > online_timeout (超时) > 无配置 (消息通知)

### 5. 离线触发方式

- **心跳/超时模式**: Redis key过期 → HeartbeatMonitor → Bus (标记source) → StatusFlow
- **消息模式**: devices/status/{id} payload=0 → Bus → StatusFlow

### 6. 离线来源标识

所有状态消息在 metadata 中携带 `source` 字段:
- `"status_message"`: 设备主动上报的状态消息
- `"heartbeat_expired"`: 心跳key过期触发
- `"timeout_expired"`: 超时key过期触发

用途: 日志记录、监控统计、区分离线原因

## 核心改进

1. **架构统一**: 状态消息也通过 Flow 层处理,与业务消息一致
2. **逻辑清晰**: 心跳/消息两种模式互斥,不会混淆
3. **职责分离**: 
   - Flow层: 业务编排和心跳刷新
   - Service层: 具体实现(Redis操作/配置管理)
   - Monitor: 过期事件监控
4. **协议无关**: 支持MQTT/HTTP/CoAP等多种协议
5. **易于扩展**: 新增协议或修改逻辑都很简单
