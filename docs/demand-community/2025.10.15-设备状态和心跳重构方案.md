# 设备状态和心跳重构方案

## 核心业务逻辑

### 在线离线的三种模式

#### 模式1: 消息通知模式 (无配置)
```yaml
配置: device_config.other_config 未配置 heartbeat 和 online_timeout
行为:
  - 完全依赖设备主动上报状态消息
  - devices/status/{id} payload=1 → 设备上线
  - devices/status/{id} payload=0 → 设备下线
  - 业务消息(telemetry/attribute/event)不影响在线状态
  - 无TTL监控
```

#### 模式2: 心跳检测模式 (heartbeat配置)
```yaml
配置: device_config.other_config 配置了 heartbeat=30 (秒)
行为:
  - 完全忽略 devices/status/{id} 消息 ❌
  - 任何业务消息(telemetry/attribute/event)都算"活跃"
  - 收到业务消息时:
      1. 如果设备当前离线 → 自动设为在线 + SSE通知 + 自动化 + 预期数据
      2. 刷新 Redis key: device:{id}:heartbeat (TTL=30秒)
  - TTL到期 → Redis过期事件 → HeartbeatMonitor → Bus → StatusFlow → 设备离线
  
特点: 平台完全控制设备状态,设备无法通过状态消息影响
```

#### 模式3: 超时检测模式 (online_timeout配置)
```yaml
配置: device_config.other_config 配置了 online_timeout=60 (秒)
行为:
  - 处理 devices/status/{id} 消息 ✅
      * payload=1 → 设备上线 + 设置TTL(60秒)
      * payload=0 → 设备离线(但保留TTL key)
  - 任何业务消息(telemetry/attribute/event):
      1. 如果设备当前离线 → 自动设为在线 + SSE通知 + 自动化 + 预期数据
      2. 刷新 Redis key: device:{id}:timeout (TTL=60秒)
  - TTL到期 → Redis过期事件 → HeartbeatMonitor → Bus → StatusFlow → 设备离线
  
特点: 混合模式,既接受设备主动上报,也有平台兜底判断,防止"假在线"
用途: 防止设备在线后长期不上报数据,实际已离线但平台未察觉
```

### 配置优先级
```
heartbeat > online_timeout > 无配置
```
- 如果配置了 `heartbeat`,则使用心跳模式,忽略 `online_timeout`
- 如果只配置了 `online_timeout`,则使用超时模式
- 都没配置,则使用消息通知模式

## 架构图

```text
入口层
└─ MQTTAdapter（后续可扩展 HTTP/CoAP）→ Flow.Bus（按消息类型分发 DeviceMessage）
       ├─ TelemetryFlow
       │     ├─ 脚本解析 / 网关拆包 → 存储服务写入
       │     ├─ HeartbeatService.RefreshHeartbeat → Redis device:{id}:{heartbeat|timeout}
       │     └─ 若设备原本离线 → 自动上线（状态更新 + SSE + 自动化 + 预期数据）
       ├─ AttributeFlow / EventFlow（流程同上，走各自入库逻辑）
       └─ StatusFlow
             ├─ 心跳模式：仅处理 source=heartbeat_expired 的离线消息
             ├─ 超时模式：上线消息设置 device:{id}:timeout TTL，离线保留 key 等待过期
             └─ 统一执行 状态入库 → 缓存清理 → Redis Pub/Sub → SSE → 自动化

Redis 过期事件（__keyevent__:*:expired）
└─ HeartbeatMonitor（service 层）
       └─ Flow.Bus.PublishStatusOffline(source=heartbeat_expired|timeout_expired)
              └─ StatusFlow 再次复用统一离线处理链路
```

## 关键业务规则

### 1. 心跳刷新时机

- **任何业务消息** (telemetry/attribute/event) 都触发心跳刷新
- 包括网关拆分后的子设备和子网关消息
- 状态消息(devices/status)不触发心跳刷新

### 2. 自动上线条件

心跳/超时模式 + 设备当前离线 + 收到业务消息 = 自动上线 + 完整上线流程(SSE + 自动化 + 预期数据)

### 3. 状态消息处理规则

- **心跳模式**: 忽略设备发来的状态消息,只处理 HeartbeatMonitor 发来的离线消息
- **超时模式**: 处理所有状态消息,上线时设置TTL,离线时保留TTL key
- **消息模式**: 处理所有状态消息

### 4. 心跳配置优先级

heartbeat (心跳) > online_timeout (超时) > 无配置 (消息通知)

### 5. 离线触发方式

- **心跳/超时模式**: Redis key过期 → HeartbeatMonitor → Bus (标记source) → StatusFlow
- **消息模式**: devices/status/{id} payload=0 → Bus → StatusFlow

### 6. 离线来源标识

所有状态消息在 metadata 中携带 `source` 字段:
- `"status_message"`: 设备主动上报的状态消息
- `"heartbeat_expired"`: 心跳key过期触发
- `"timeout_expired"`: 超时key过期触发

用途: 日志记录、监控统计、区分离线原因

## 核心改进

1. **架构统一**: 状态消息也通过 Flow 层处理,与业务消息一致
2. **逻辑清晰**: 心跳/消息两种模式互斥,不会混淆
3. **职责分离**: 
   - Flow层: 业务编排和心跳刷新
   - Service层: 具体实现(Redis操作/配置管理)
   - Monitor: 过期事件监控
4. **协议无关**: 支持MQTT/HTTP/CoAP等多种协议
5. **易于扩展**: 新增协议或修改逻辑都很简单
