# ThingsPanel 多级网关改造技术方案

## 1. 改造目标

将现有的单层网关架构升级为支持多级网关的架构，使系统能够处理：
- **网关 → 子网关 → 子设备** 的多级拓扑结构
- 所有四类交互数据（遥测、属性、事件、命令）的多级传输
- 保持向后兼容性，不影响现有单层网关的正常工作

## 2. 现状分析

### 2.1 当前架构
- **单层结构**：网关 → 普通子设备
- **数据结构**：
  ```json
  {
    "gateway_data": {...},
    "sub_device_data": {...}
  }
  ```
- **处理流程**：网关数据和子设备数据分别处理
- **数据库结构**：`devices` 表已有 `parent_id` 字段支持父子关系

### 2.2 现有代码模块
- **MQTT 消息处理**：`mqtt/subscribe/gateway_*_message.go`
- **数据模型**：`internal/model/gateway.go`
- **设备模型**：`internal/model/devices.gen.go` - 已包含 `parent_id` 字段
- **API 接口**：设备选择器和批量配置接口
- **业务服务**：设备管理和配置服务

### 2.3 现有优势
- **数据库已就绪**：`parent_id` 字段可以支持任意层级的父子关系
- **架构灵活**：现有设计已经为多层级结构预留了扩展空间
- **改造成本较低**：主要是逻辑层面的扩展，无需大量数据库改动

## 3. 技术改造方案

### 3.1 数据模型扩展

#### 3.1.1 扩展现有 Gateway 模型 (`internal/model/gateway.go`)

```go
// 新增多级网关数据结构
type MultiLevelGatewayData struct {
    GatewayData   *map[string]interface{}            `json:"gateway_data"`
    SubDeviceData *map[string]map[string]interface{} `json:"sub_device_data"`
    SubGatewayData *map[string]*MultiLevelGatewayData `json:"sub_gateway_data,omitempty"`
}

// 扩展现有结构以支持多级
type GatewayPublishV2 struct {
    GatewayData    *map[string]interface{}            `json:"gateway_data"`
    SubDeviceData  *map[string]map[string]interface{} `json:"sub_device_data"`
    SubGatewayData *map[string]*MultiLevelGatewayData `json:"sub_gateway_data,omitempty"`
}

// 命令下发多级结构
type GatewayCommandPublishV2 struct {
    GatewayData    *EventInfo                        `json:"gateway_data"`
    SubDeviceData  *map[string]EventInfo             `json:"sub_device_data"`
    SubGatewayData *map[string]*GatewayCommandPublishV2 `json:"sub_gateway_data,omitempty"`
}

// 属性获取多级结构
type GatewayAttributeGetV2 struct {
    GatewayData    *[]string                         `json:"gateway_data"`
    SubDeviceData  *map[string][]string              `json:"sub_device_data"`
    SubGatewayData *map[string]*GatewayAttributeGetV2 `json:"sub_gateway_data,omitempty"`
}
```

#### 3.1.2 数据库模型分析

现有 `devices` 表已经包含了必要的字段：
- `parent_id`: 子设备的网关ID（已存在）
- `device_type`: 设备类型，可以区分网关和普通设备

**无需修改数据库结构**，现有字段已足够支持多级网关：
```sql
-- 现有结构已经支持多级关系
-- parent_id 字段可以指向任何设备ID（包括网关设备）
-- 通过递归查询可以构建完整的设备树
```

### 3.2 MQTT 消息处理改造

#### 3.2.1 遥测消息处理 (`mqtt/subscribe/gateway_telemetry_message.go`)

```go
// 新增递归处理函数
func processMultiLevelTelemetryData(gatewayInfo *model.Device, data *MultiLevelGatewayData, topic string) {
    // 处理当前网关数据
    if data.GatewayData != nil {
        gatewayBody, err := json.Marshal(data.GatewayData)
        if err == nil {
            telemetryMessagesHandleCore(gatewayInfo, gatewayBody, topic)
        }
    }
    
    // 处理直接子设备数据
    if data.SubDeviceData != nil {
        var subDeviceAddrs []string
        for deviceAddr := range *data.SubDeviceData {
            subDeviceAddrs = append(subDeviceAddrs, deviceAddr)
        }
        subDeviceInfos, _ := dal.GetDeviceBySubDeviceAddress(subDeviceAddrs, gatewayInfo.ID)
        for subDeviceAddr, deviceData := range *data.SubDeviceData {
            if subInfo, ok := subDeviceInfos[subDeviceAddr]; ok {
                subDeviceBody, err := json.Marshal(deviceData)
                if err == nil {
                    TelemetryMessagesHandle(subInfo, subDeviceBody, topic)
                }
            }
        }
    }
    
    // 递归处理子网关数据
    if data.SubGatewayData != nil {
        var subGatewayAddrs []string
        for gatewayAddr := range *data.SubGatewayData {
            subGatewayAddrs = append(subGatewayAddrs, gatewayAddr)
        }
        subGatewayInfos, _ := dal.GetDeviceBySubDeviceAddress(subGatewayAddrs, gatewayInfo.ID)
        for subGatewayAddr, subGatewayData := range *data.SubGatewayData {
            if subGatewayInfo, ok := subGatewayInfos[subGatewayAddr]; ok {
                // 递归处理子网关及其下属设备
                processMultiLevelTelemetryData(subGatewayInfo, subGatewayData, topic)
            }
        }
    }
}

// 修改主处理函数
func GatewayTelemetryMessagesV2(payload []byte, topic string) {
    // 兼容性处理：先尝试解析新版格式
    newPayloads := &GatewayPublishV2{}
    if err := json.Unmarshal(processedValues, newPayloads); err == nil && newPayloads.SubGatewayData != nil {
        // 新版多级格式
        multiLevelData := &MultiLevelGatewayData{
            GatewayData:    newPayloads.GatewayData,
            SubDeviceData:  newPayloads.SubDeviceData,
            SubGatewayData: newPayloads.SubGatewayData,
        }
        processMultiLevelTelemetryData(deviceInfo, multiLevelData, topic)
    } else {
        // 回退到旧版处理逻辑
        GatewayTelemetryMessages(payload, topic)
    }
}
```

#### 3.2.2 属性消息处理 (`mqtt/subscribe/gateway_attribute_message.go`)
类似的递归处理逻辑，支持多级属性数据处理。

#### 3.2.3 事件消息处理 (`mqtt/subscribe/gateway_event_message.go`)
类似的递归处理逻辑，支持多级事件数据处理。

#### 3.2.4 命令消息处理 (`mqtt/subscribe/gateway_command_message.go`)
支持多级命令下发的递归处理。

### 3.3 API 接口改造

#### 3.3.1 设备选择器接口改造 (`internal/api/device.go`)

```go
// 扩展设备选择器以支持网关设备选择
func (*DeviceApi) HandleDeviceSelector(c *gin.Context) {
    var req model.GetDeviceSelectorReq
    if !BindAndValidate(c, &req) {
        return
    }
    
    // 添加支持网关设备类型的查询参数
    req.SupportGatewaySelection = true
    
    userClaims := c.MustGet("claims").(*utils.UserClaims)
    list, err := service.GroupApp.Device.GetDeviceSelectorV2(req, userClaims)
    if err != nil {
        c.Error(err)
        return
    }
    c.Set("data", list)
}
```

#### 3.3.2 批量配置接口扩展 (`internal/api/device_config.go`)

```go
// 扩展批量配置支持网关到网关的绑定
func (*DeviceConfigApi) BatchUpdateDeviceConfigV2(c *gin.Context) {
    var req model.BatchUpdateDeviceConfigV2Req
    if !BindAndValidate(c, &req) {
        return
    }

    // 支持网关设备的多级绑定
    err := service.GroupApp.DeviceConfig.BatchUpdateDeviceConfigV2(&req)
    if err != nil {
        c.Error(err)
        return
    }

    c.Set("data", nil)
}
```

### 3.4 数据访问层改造

#### 3.4.1 设备查询扩展 (`internal/dal/devices.go`)

```go
// 新增支持网关设备查询的方法
func GetAvailableGatewayDevices(tenantId string, excludeGatewayId string) ([]*model.Device, error) {
    var devices []*model.Device
    err := query.Device.Where(
        query.Device.TenantID.Eq(tenantId),
        query.Device.DeviceType.Eq("gateway"), // 网关设备类型
        query.Device.ID.Neq(excludeGatewayId), // 排除当前网关
        query.Device.ParentID.IsNull(), // 未绑定到其他网关
    ).Find(&devices)
    
    return devices, err
}

// 支持递归查询设备树结构
func GetDeviceTreeByGatewayId(gatewayId string) (*DeviceTree, error) {
    // 递归查询设备及其子设备/子网关
    // 返回完整的设备树结构
}
```

#### 3.4.2 设备配置扩展 (`internal/dal/device_config.go`)

```go
// 支持多级网关绑定的配置更新（直接使用现有的parent_id字段）
func BatchUpdateDeviceParentBinding(configs []*model.BatchUpdateDeviceConfigItem) error {
    return query.Q.Transaction(func(tx *query.Query) error {
        for _, config := range configs {
            // 支持网关设备到网关设备的绑定
            if config.ParentId != nil {
                // 验证父设备是否为网关设备类型
                parentDevice, err := tx.Device.Where(tx.Device.ID.Eq(*config.ParentId)).First()
                if err != nil {
                    return fmt.Errorf("父设备不存在: %s", *config.ParentId)
                }
                if parentDevice.DeviceType == nil || *parentDevice.DeviceType != "gateway" {
                    return fmt.Errorf("父设备必须为网关类型")
                }
            }
            
            // 直接更新devices表的parent_id字段
            err := tx.Device.Where(
                tx.Device.ID.Eq(config.DeviceId),
            ).Updates(map[string]interface{}{
                "parent_id": config.ParentId,
            })
            
            if err != nil {
                return err
            }
        }
        return nil
    })
}
```

### 3.5 业务服务层改造

#### 3.5.1 设备服务扩展 (`internal/service/device.go`)

```go
// 扩展设备选择器服务
func (*DeviceService) GetDeviceSelectorV2(req model.GetDeviceSelectorReq, userClaims *utils.UserClaims) ([]*model.DeviceSelectorResp, error) {
    var devices []*model.Device
    var err error
    
    if req.SupportGatewaySelection {
        // 返回未绑定的子设备和未绑定的网关设备
        devices, err = dal.GetUnboundDevicesAndGateways(userClaims.TenantID, req.ExcludeGatewayId)
    } else {
        // 原有逻辑：只返回子设备
        devices, err = dal.GetUnboundDevices(userClaims.TenantID, req.ExcludeGatewayId)
    }
    
    // 转换为响应格式，标识设备类型
    return convertToDeviceSelectorResp(devices), err
}

// 设备树形结构查询
func (*DeviceService) GetDeviceTree(gatewayId string) (*DeviceTreeResp, error) {
    tree, err := dal.GetDeviceTreeByGatewayId(gatewayId)
    if err != nil {
        return nil, err
    }
    
    return convertToDeviceTreeResp(tree), nil
}
```

#### 3.5.2 设备配置服务扩展 (`internal/service/device_config.go`)

```go
// 支持多级网关配置的批量更新（使用现有parent_id字段）
func (*DeviceConfigService) BatchUpdateDeviceParentBinding(req *model.BatchUpdateDeviceConfigV2Req) error {
    // 验证网关设备绑定的合法性
    for _, config := range req.Configs {
        if config.ParentId != nil {
            // 验证父设备是否为网关类型
            parentDevice, err := dal.GetDeviceById(*config.ParentId)
            if err != nil {
                return errors.New("父网关设备不存在")
            }
            if parentDevice.DeviceType == nil || *parentDevice.DeviceType != "gateway" {
                return errors.New("父设备必须为网关类型")
            }
            
            // 防止循环绑定
            if err := validateNoCircularBinding(config.DeviceId, *config.ParentId); err != nil {
                return err
            }
        }
    }
    
    return dal.BatchUpdateDeviceParentBinding(req.Configs)
}
```

### 3.6 前端接口模型扩展

#### 3.6.1 请求响应模型 (`internal/model/devices.http.go`)

```go
// 设备选择器响应扩展
type DeviceSelectorV2Resp struct {
    ID         string `json:"id"`
    Name       string `json:"name"`
    DeviceType string `json:"device_type"` // 标识是否为网关设备
    IsGateway  bool   `json:"is_gateway"`  // 是否为网关设备
}

// 批量配置请求扩展
type BatchUpdateDeviceConfigV2Req struct {
    Configs []*BatchUpdateDeviceConfigV2Item `json:"configs"`
}

type BatchUpdateDeviceConfigV2Item struct {
    DeviceId string  `json:"device_id"`
    ParentId *string `json:"parent_id"` // 使用现有的parent_id字段，支持网关绑定
    // ... 其他配置字段
}

// 设备树响应模型
type DeviceTreeResp struct {
    Gateway    *DeviceNodeResp   `json:"gateway"`
    SubDevices []*DeviceNodeResp `json:"sub_devices"`
    SubGateways []*DeviceTreeResp `json:"sub_gateways"`
}

type DeviceNodeResp struct {
    ID         string `json:"id"`
    Name       string `json:"name"`
    DeviceType string `json:"device_type"`
    Status     string `json:"status"`
}
```

### 3.7 路由配置更新

#### 3.7.1 新增路由 (`router/apps/device.go`)

```go
// 设备相关路由扩展
func (*DeviceRouter) InitDeviceRouterV2(Router *gin.RouterGroup) {
    deviceRouter := Router.Group("device")
    deviceApi := api.GroupApp.DeviceApi
    
    // 扩展现有接口
    deviceRouter.GET("/selector/v2", deviceApi.HandleDeviceSelectorV2)
    deviceRouter.GET("/tree/:id", deviceApi.HandleDeviceTree)
}
```

#### 3.7.2 设备配置路由扩展 (`router/apps/device_config.go`)

```go
// 设备配置路由扩展
func (*DeviceConfigRouter) InitDeviceConfigRouterV2(Router *gin.RouterGroup) {
    deviceConfigRouter := Router.Group("device_config")
    deviceConfigApi := api.GroupApp.DeviceConfigApi
    
    // 支持多级绑定的批量更新接口
    deviceConfigRouter.PUT("/batch/v2", deviceConfigApi.BatchUpdateDeviceConfigV2)
}
```

## 4. 兼容性保证

### 4.1 向后兼容策略

1. **保持现有接口不变**：原有 API 接口继续正常工作
2. **数据格式兼容**：新的数据结构包含 `sub_gateway_data` 为可选字段
3. **渐进式升级**：支持新旧数据格式混合处理

### 4.2 兼容性处理逻辑

```go
// MQTT 消息处理兼容性示例
func GatewayTelemetryMessagesWithCompatibility(payload []byte, topic string) {
    // 先尝试新格式
    if processAsMultiLevel(payload, topic) {
        return
    }
    
    // 回退到旧格式处理
    GatewayTelemetryMessages(payload, topic)
}

func processAsMultiLevel(payload []byte, topic string) bool {
    newPayloads := &GatewayPublishV2{}
    if err := json.Unmarshal(payload, newPayloads); err != nil {
        return false
    }
    
    // 如果包含 sub_gateway_data，则按新格式处理
    if newPayloads.SubGatewayData != nil {
        // 新格式处理逻辑
        return true
    }
    
    return false
}
```

## 5. 实施计划

### 5.1 阶段一：数据模型和基础设施

1. **数据模型扩展** (1-2天)
   - 扩展 `internal/model/gateway.go`
   - 数据库表结构调整
   - 基础数据访问接口

2. **核心处理逻辑** (3-4天)
   - MQTT 消息处理函数递归逻辑
   - 兼容性处理机制

### 5.2 阶段二：API 接口改造

1. **设备选择器接口** (1-2天)
   - API 接口扩展
   - 服务层逻辑实现
   - 数据访问层查询优化

2. **批量配置接口** (2-3天)
   - 支持网关到网关绑定
   - 循环绑定检测
   - 批量操作优化

### 5.3 阶段三：测试和优化

1. **单元测试** (2-3天)
   - 核心处理逻辑测试
   - 兼容性测试
   - 边界条件测试

2. **集成测试** (2-3天)
   - 端到端测试
   - 性能测试
   - 压力测试

### 5.4 阶段四：文档和部署

1. **文档更新** (1天)
   - API 文档更新
   - 部署指南更新

2. **部署上线** (1天)
   - 数据库迁移脚本
   - 灰度发布
   - 监控告警

## 6. 风险评估与应对

### 6.1 技术风险

| 风险 | 影响 | 概率 | 应对措施 |
|------|------|------|----------|
| 递归处理性能问题 | 高 | 中 | 限制递归深度、异步处理、缓存优化 |
| 数据一致性问题 | 高 | 低 | 事务处理、回滚机制 |
| 兼容性问题 | 中 | 低 | 充分测试、渐进式发布 |

### 6.2 业务风险

| 风险 | 影响 | 概率 | 应对措施 |
|------|------|------|----------|
| 用户体验变化 | 中 | 低 | UI/UX 设计优化、用户培训 |
| 数据迁移风险 | 高 | 低 | 备份策略、回滚预案 |

## 7. 性能优化建议

### 7.1 处理性能优化

1. **限制递归深度**：防止过深的网关嵌套影响性能
2. **批量处理**：对同一网关下的多个设备数据进行批量处理
3. **缓存策略**：缓存设备关系树结构，减少数据库查询

### 7.2 数据库优化

1. **索引优化**：为父网关ID字段添加索引
2. **查询优化**：使用递归查询或CTE优化设备树查询
3. **连接池配置**：调整数据库连接池大小

## 8. 监控和告警

### 8.1 关键指标监控

1. **处理延迟**：多级数据处理的平均延迟
2. **错误率**：递归处理中的错误比率
3. **资源使用**：CPU、内存使用率监控

### 8.2 告警策略

1. **性能告警**：处理延迟超过阈值
2. **错误告警**：错误率超过预设值
3. **容量告警**：递归深度或设备数量超限

## 9. 总结

本改造方案通过扩展现有数据模型和处理逻辑，实现了对多级网关架构的全面支持，同时保持了向后兼容性。通过递归处理机制和兼容性设计，确保了系统能够同时处理新旧两种数据格式，为用户提供平滑的升级体验。

改造完成后，系统将能够支持任意层级的网关拓扑结构，满足复杂场景下的设备管理需求，同时为未来的功能扩展奠定了坚实的基础。